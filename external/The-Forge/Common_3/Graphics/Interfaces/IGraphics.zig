// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

// TIDES: BEGIN MANUAL CHANGES
const tiny_image_format = @import("TinyImageFormat.zig");
pub const TinyImageFormat = tiny_image_format.TinyImageFormat;
const gpu_cmd_ring = @import("GpuCmdRing.zig");
pub const GpuCmdRing = gpu_cmd_ring.GpuCmdRing;
pub const GpuCmdRingElememnt = gpu_cmd_ring.GpuCmdRingElement;
pub const GpuCmdRingDesc = gpu_cmd_ring.GpuCmdRingDesc;

pub fn byteSizeOfBlock(format: TinyImageFormat) u32 {
    return tiny_image_format.bitSizeOfBlock(format) >> 3;
}

const DWORD = u32;
const WCHAR = u16;
const D3D_FEATURE_LEVEL = u32;
const D3D12_GPU_VIRTUAL_ADDRESS = u64;
const D3D12_QUERY_TYPE = u32;
const HANDLE = *anyopaque;
const ID3D12CommandAllocator = anyopaque;
const ID3D12CommandQueue = anyopaque;
const ID3D12CommandSignature = anyopaque;
const ID3D12Debug = anyopaque;
const ID3D12DescriptorHeap = anyopaque;
const ID3D12Device = anyopaque;
const ID3D12Fence = anyopaque;
const ID3D12GraphicsCommandList1 = anyopaque;
const ID3D12Heap = anyopaque;
const ID3D12InfoQueue = anyopaque;
const ID3D12InfoQueue1 = anyopaque;
const ID3D12DebugCommandList = anyopaque;
const ID3D12PipelineLibrary = anyopaque;
const ID3D12PipelineState = anyopaque;
const ID3D12QueryHeap = anyopaque;
const ID3D12Resource = anyopaque;
const ID3D12RootSignature = anyopaque;
const ID3D12StateObject = anyopaque;
const IDxcBlobEncoding = anyopaque;
const IDXGIAdapter4 = anyopaque;
const IDXGIFactory6 = anyopaque;
const IDXGISwapChain3 = anyopaque;
const LogLevel = u32;
const LPCWSTR = *anyopaque;
const Mutex = anyopaque;
const PipelineReflection = anyopaque;

pub const D3D12_CPU_DESCRIPTOR_HANDLE = extern struct {
    ptr: u64,
};

pub const D3D12_GPU_DESCRIPTOR_HANDLE = extern struct {
    ptr: u64,
};

pub const D3D12_PROGRAM_IDENTIFIER = extern struct {
    opaque_data: [4]u64,
};

/// D3D structs definitions copied from zig-gamdev/zwin32/d3dcommon.zig
pub const D3D_PRIMITIVE_TOPOLOGY = enum(u32) {
    D3D_PRIMITIVE_TOPOLOGY_UNDEFINED = 0,
    D3D_PRIMITIVE_TOPOLOGY_POINTLIST = 1,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST = 2,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP = 3,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST = 4,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP = 5,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ = 10,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ = 11,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ = 12,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ = 13,
    D3D_PRIMITIVE_TOPOLOGY_CONTROL_POINT_PATCHLIST = 33,
    D3D_PRIMITIVE_TOPOLOTY_2_CONTROL_POINT_PATCHLIST = 34,
    D3D_PRIMITIVE_TOPOLOTY_3_CONTROL_POINT_PATCHLIST = 35,
    D3D_PRIMITIVE_TOPOLOTY_4_CONTROL_POINT_PATCHLIST = 36,
    D3D_PRIMITIVE_TOPOLOTY_5_CONTROL_POINT_PATCHLIST = 37,
    D3D_PRIMITIVE_TOPOLOTY_6_CONTROL_POINT_PATCHLIST = 38,
    D3D_PRIMITIVE_TOPOLOTY_7_CONTROL_POINT_PATCHLIST = 39,
    D3D_PRIMITIVE_TOPOLOTY_8_CONTROL_POINT_PATCHLIST = 40,
    D3D_PRIMITIVE_TOPOLOTY_9_CONTROL_POINT_PATCHLIST = 41,
    D3D_PRIMITIVE_TOPOLOTY_10_CONTROL_POINT_PATCHLIST = 42,
    D3D_PRIMITIVE_TOPOLOTY_11_CONTROL_POINT_PATCHLIST = 43,
    D3D_PRIMITIVE_TOPOLOTY_12_CONTROL_POINT_PATCHLIST = 44,
    D3D_PRIMITIVE_TOPOLOTY_13_CONTROL_POINT_PATCHLIST = 45,
    D3D_PRIMITIVE_TOPOLOTY_14_CONTROL_POINT_PATCHLIST = 46,
    D3D_PRIMITIVE_TOPOLOTY_15_CONTROL_POINT_PATCHLIST = 47,
    D3D_PRIMITIVE_TOPOLOTY_16_CONTROL_POINT_PATCHLIST = 48,
    D3D_PRIMITIVE_TOPOLOTY_17_CONTROL_POINT_PATCHLIST = 49,
    D3D_PRIMITIVE_TOPOLOTY_18_CONTROL_POINT_PATCHLIST = 50,
    D3D_PRIMITIVE_TOPOLOTY_19_CONTROL_POINT_PATCHLIST = 51,
    D3D_PRIMITIVE_TOPOLOTY_20_CONTROL_POINT_PATCHLIST = 52,
    D3D_PRIMITIVE_TOPOLOTY_21_CONTROL_POINT_PATCHLIST = 53,
    D3D_PRIMITIVE_TOPOLOTY_22_CONTROL_POINT_PATCHLIST = 54,
    D3D_PRIMITIVE_TOPOLOTY_23_CONTROL_POINT_PATCHLIST = 55,
    D3D_PRIMITIVE_TOPOLOTY_24_CONTROL_POINT_PATCHLIST = 56,
    D3D_PRIMITIVE_TOPOLOTY_25_CONTROL_POINT_PATCHLIST = 57,
    D3D_PRIMITIVE_TOPOLOTY_26_CONTROL_POINT_PATCHLIST = 58,
    D3D_PRIMITIVE_TOPOLOTY_27_CONTROL_POINT_PATCHLIST = 59,
    D3D_PRIMITIVE_TOPOLOTY_28_CONTROL_POINT_PATCHLIST = 60,
    D3D_PRIMITIVE_TOPOLOTY_29_CONTROL_POINT_PATCHLIST = 61,
    D3D_PRIMITIVE_TOPOLOTY_30_CONTROL_POINT_PATCHLIST = 62,
    D3D_PRIMITIVE_TOPOLOTY_31_CONTROL_POINT_PATCHLIST = 63,
    D3D_PRIMITIVE_TOPOLOTY_32_CONTROL_POINT_PATCHLIST = 64,
};

pub const D3D12_SAMPLER_DESC = extern struct {
    Filter: D3D12_FILTER,
    AddressU: D3D12_TEXTURE_ADDRESS_MODE,
    AddressV: D3D12_TEXTURE_ADDRESS_MODE,
    AddressW: D3D12_TEXTURE_ADDRESS_MODE,
    MipLODBias: f32,
    MaxAnisotropy: u32,
    ComparisonFunc: D3D12_COMPARISON_FUNC,
    BorderColor: [4]f32,
    MinLOD: f32,
    MaxLOD: f32,
};

pub const D3D12_FILTER = enum(u32) {
    MIN_MAG_MIP_POINT = 0,
    MIN_MAG_POINT_MIP_LINEAR = 0x1,
    MIN_POINT_MAG_LINEAR_MIP_POINT = 0x4,
    MIN_POINT_MAG_MIP_LINEAR = 0x5,
    MIN_LINEAR_MAG_MIP_POINT = 0x10,
    MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x11,
    MIN_MAG_LINEAR_MIP_POINT = 0x14,
    MIN_MAG_MIP_LINEAR = 0x15,
    ANISOTROPIC = 0x55,
    COMPARISON_MIN_MAG_MIP_POINT = 0x80,
    COMPARISON_MIN_MAG_POINT_MIP_LINEAR = 0x81,
    COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x84,
    COMPARISON_MIN_POINT_MAG_MIP_LINEAR = 0x85,
    COMPARISON_MIN_LINEAR_MAG_MIP_POINT = 0x90,
    COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x91,
    COMPARISON_MIN_MAG_LINEAR_MIP_POINT = 0x94,
    COMPARISON_MIN_MAG_MIP_LINEAR = 0x95,
    COMPARISON_ANISOTROPIC = 0xd5,
    MINIMUM_MIN_MAG_MIP_POINT = 0x100,
    MINIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x101,
    MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x104,
    MINIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x105,
    MINIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x110,
    MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x111,
    MINIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x114,
    MINIMUM_MIN_MAG_MIP_LINEAR = 0x115,
    MINIMUM_ANISOTROPIC = 0x155,
    MAXIMUM_MIN_MAG_MIP_POINT = 0x180,
    MAXIMUM_MIN_MAG_POINT_MIP_LINEAR = 0x181,
    MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT = 0x184,
    MAXIMUM_MIN_POINT_MAG_MIP_LINEAR = 0x185,
    MAXIMUM_MIN_LINEAR_MAG_MIP_POINT = 0x190,
    MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR = 0x191,
    MAXIMUM_MIN_MAG_LINEAR_MIP_POINT = 0x194,
    MAXIMUM_MIN_MAG_MIP_LINEAR = 0x195,
    MAXIMUM_ANISOTROPIC = 0x1d5,
};

pub const D3D12_TEXTURE_ADDRESS_MODE = enum(u32) {
    WRAP = 1,
    MIRROR = 2,
    CLAMP = 3,
    BORDER = 4,
    MIRROR_ONCE = 5,
};

pub const D3D12_COMPARISON_FUNC = enum(u32) {
    NEVER = 1,
    LESS = 2,
    EQUAL = 3,
    LESS_EQUAL = 4,
    GREATER = 5,
    NOT_EQUAL = 6,
    GREATER_EQUAL = 7,
    ALWAYS = 8,
};

pub const D3D12_DESCRIPTOR_HEAP_TYPE = enum(u32) {
    D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
    D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER,
    D3D12_DESCRIPTOR_HEAP_TYPE_RTV,
    D3D12_DESCRIPTOR_HEAP_TYPE_DSV,
    D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES,
};

pub const DescriptorHeap = extern struct {
    /// DX Heap
    pHeap: *ID3D12DescriptorHeap,
    /// Lock for multi-threaded descriptor allocations
    mMutex: std.os.windows.CRITICAL_SECTION, // NOTE(gmodarelli): Windows-only
    pDevice: *ID3D12Device,
    /// Start position in the heap
    mStartCpuHandle: D3D12_CPU_DESCRIPTOR_HANDLE,
    mStartGpuHandle: D3D12_GPU_DESCRIPTOR_HANDLE,
    // Bitmask to track free regions (set bit means occupied)
    pFlags: *u32,
    /// Description
    mType: D3D12_DESCRIPTOR_HEAP_TYPE,
    mNumDescriptors: u32,
    /// Descriptor Increment Size
    mDescriptorSize: u32,
    // Usage
    mUsedDescriptors: u32,
};

pub const ExtendedSettings = extern struct {
    mNumSettings: u32,
    pSettings: *u32,
    ppSettingNames: [*c][*c]const u8,
};

pub const GPUPresetLevel = enum(u32) {
    GPU_PRESET_NONE = 0,
    GPU_PRESET_OFFICE, // This means unsupported
    GPU_PRESET_VERYLOW, // Mostly for mobile GPU
    GPU_PRESET_LOW,
    GPU_PRESET_MEDIUM,
    GPU_PRESET_HIGH,
    GPU_PRESET_ULTRA,
    GPU_PRESET_COUNT,
};

/// Taken from IOperatingSystem.h
pub const ReloadType = packed struct(u32) {
    RESIZE: bool = false, // 0x1
    SHADER: bool = false, // 0x2
    RENDERTARGET: bool = false, // 0x4,
    __unused: u28 = 0,
    ALL: bool = false, // 0xffffffff

    pub const RESIZE_RENDERTARGET = ReloadType{
        .RESIZE = true,
        .RENDERTARGET = true,
    };

    pub const RESIZE_SHADER_RENDERTARGET = ReloadType{
        .RESIZE = true,
        .SHADER = true,
        .RENDERTARGET = true,
    };
};

pub const ReloadDesc = struct {
    mType: ReloadType,
};

// NOTE(gmodarelli): I've only manually written the bindings for Win32
pub const WindowHandle = extern struct {
    type: WindowHandleType,
    window: std.os.windows.HWND,
};

pub const WindowHandleType = enum(u32) {
    UNKNOWN,
    WIN32,
    XLIB,
    XCB,
    WAYLAND,
    ANDROID,
    VI_NN,
};
// TIDES: END MANUAL CHANGES

/// Forward declare opaque memory allocator structs
pub const DxDescriptorID = i32;

pub const RendererApi = extern struct {
    bits: c_int = 0,

    pub const RENDERER_API_D3D12: RendererApi = .{ .bits = 0 };
    pub const RENDERER_API_COUNT: RendererApi = .{ .bits = 1 };

    // pub usingnamespace cpp.FlagsMixin(RendererApi);
};

pub const QueueType = extern struct {
    bits: c_int = 0,

    pub const QUEUE_TYPE_GRAPHICS: QueueType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUEUE_TYPE_TRANSFER: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 1 };
    pub const QUEUE_TYPE_COMPUTE: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 2 };
    pub const MAX_QUEUE_TYPE: QueueType = .{ .bits = QueueType.QUEUE_TYPE_GRAPHICS.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(QueueType);
};

pub const QueueFlag = extern struct {
    bits: c_int = 0,

    pub const QUEUE_FLAG_NONE: QueueFlag = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUEUE_FLAG_DISABLE_GPU_TIMEOUT: QueueFlag = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const QUEUE_FLAG_INIT_MICROPROFILE: QueueFlag = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const MAX_QUEUE_FLAG: QueueFlag = .{ .bits = 4294967295 };

    // pub usingnamespace cpp.FlagsMixin(QueueFlag);
};

pub const QueuePriority = extern struct {
    bits: c_int = 0,

    pub const QUEUE_PRIORITY_NORMAL: QueuePriority = .{ .bits = 0 };
    pub const QUEUE_PRIORITY_HIGH: QueuePriority = .{ .bits = 1 };
    pub const QUEUE_PRIORITY_GLOBAL_REALTIME: QueuePriority = .{ .bits = 2 };
    pub const MAX_QUEUE_PRIORITY: QueuePriority = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(QueuePriority);
};

pub const LoadActionType = extern struct {
    bits: c_int = 0,

    pub const LOAD_ACTION_DONTCARE: LoadActionType = .{ .bits = 0 };
    pub const LOAD_ACTION_LOAD: LoadActionType = .{ .bits = 1 };
    pub const LOAD_ACTION_CLEAR: LoadActionType = .{ .bits = 2 };
    pub const MAX_LOAD_ACTION: LoadActionType = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(LoadActionType);
};

pub const StoreActionType = extern struct {
    bits: c_int = 0,

    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_STORE: StoreActionType = .{ .bits = 0 };
    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_DONTCARE: StoreActionType = .{ .bits = 1 };
    /// Store is the most common use case so keep that as default
    pub const STORE_ACTION_NONE: StoreActionType = .{ .bits = 2 };
    pub const MAX_STORE_ACTION: StoreActionType = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(StoreActionType);
};

pub const LogFn = ?*const fn (LogLevel, [*c]const u8, [*c]const u8) callconv(.C) void;

pub const ResourceState = extern struct {
    bits: c_int = 0,

    pub const RESOURCE_STATE_UNDEFINED: ResourceState = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER: ResourceState = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const RESOURCE_STATE_INDEX_BUFFER: ResourceState = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const RESOURCE_STATE_RENDER_TARGET: ResourceState = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const RESOURCE_STATE_UNORDERED_ACCESS: ResourceState = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const RESOURCE_STATE_DEPTH_WRITE: ResourceState = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const RESOURCE_STATE_DEPTH_READ: ResourceState = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const RESOURCE_STATE_PIXEL_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const RESOURCE_STATE_SHADER_RESOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(64 | 128)) };
    pub const RESOURCE_STATE_STREAM_OUT: ResourceState = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const RESOURCE_STATE_INDIRECT_ARGUMENT: ResourceState = .{ .bits = @as(c_uint, @intCast(512)) };
    pub const RESOURCE_STATE_COPY_DEST: ResourceState = .{ .bits = @as(c_uint, @intCast(1024)) };
    pub const RESOURCE_STATE_COPY_SOURCE: ResourceState = .{ .bits = @as(c_uint, @intCast(2048)) };
    pub const RESOURCE_STATE_GENERIC_READ: ResourceState = .{ .bits = @as(c_uint, @intCast((((((1 | 2) | 64) | 128) | 512) | 2048))) };
    pub const RESOURCE_STATE_PRESENT: ResourceState = .{ .bits = @as(c_uint, @intCast(4096)) };
    pub const RESOURCE_STATE_COMMON: ResourceState = .{ .bits = @as(c_uint, @intCast(8192)) };
    pub const RESOURCE_STATE_ACCELERATION_STRUCTURE_READ: ResourceState = .{ .bits = @as(c_uint, @intCast(16384)) };
    pub const RESOURCE_STATE_ACCELERATION_STRUCTURE_WRITE: ResourceState = .{ .bits = @as(c_uint, @intCast(32768)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceState);
};

/// Choosing Memory Type
pub const ResourceMemoryUsage = extern struct {
    bits: c_int = 0,

    /// No intended memory usage specified.
    pub const RESOURCE_MEMORY_USAGE_UNKNOWN: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Memory will be used on device only, no need to be mapped on host.
    pub const RESOURCE_MEMORY_USAGE_GPU_ONLY: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Memory will be mapped on host. Could be used for transfer to device.
    pub const RESOURCE_MEMORY_USAGE_CPU_ONLY: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Memory will be used for frequent (dynamic) updates from host and reads on device.
    pub const RESOURCE_MEMORY_USAGE_CPU_TO_GPU: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(3)) };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_GPU_TO_CPU: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_COUNT: ResourceMemoryUsage = .{ .bits = ResourceMemoryUsage.RESOURCE_MEMORY_USAGE_GPU_TO_CPU.bits + 1 };
    /// Memory will be used for writing on device and readback on host.
    pub const RESOURCE_MEMORY_USAGE_MAX_ENUM: ResourceMemoryUsage = .{ .bits = @as(c_uint, @intCast(2147483647)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceMemoryUsage);
};

/// Choosing Memory Type
pub const GPUSelection = extern struct {
    /// Available GPU capabilities
    ppAvailableGpuNames: [256][4]u8,
    pAvailableGpuIds: [4]u32,
    mAvailableGpuCount: u32,
    mSelectedGpuIndex: u32,
    /// Could add swap chain size, render target format, ...
    mPreferedGpuId: u32,
};

// TIDES: BEGIN MANUAL CHANGES
/// Forward declarations
// pub const Renderer = Renderer;
// TIDES: END MANUAL CHANGES

/// Raytracing
pub const IndirectDrawArguments = extern struct {
    mVertexCount: u32,
    mInstanceCount: u32,
    mStartVertex: u32,
    mStartInstance: u32,
};

pub const IndirectDrawIndexArguments = extern struct {
    mIndexCount: u32,
    mInstanceCount: u32,
    mStartIndex: u32,
    mVertexOffset: u32,
    mStartInstance: u32,
};

pub const IndirectDispatchArguments = extern struct {
    mGroupCountX: u32,
    mGroupCountY: u32,
    mGroupCountZ: u32,
};

pub const IndirectDispatchMeshArguments = extern struct {
    mGroupCountX: u32,
    mGroupCountY: u32,
    mGroupCountZ: u32,
};

pub const IndirectArgumentType = extern struct {
    bits: c_int = 0,

    pub const INDIRECT_DRAW: IndirectArgumentType = .{ .bits = 0 };
    pub const INDIRECT_DRAW_INDEX: IndirectArgumentType = .{ .bits = 1 };
    pub const INDIRECT_DISPATCH: IndirectArgumentType = .{ .bits = 2 };
    /// metal ICB
    pub const INDIRECT_COMMAND_BUFFER: IndirectArgumentType = .{ .bits = 3 };
    /// metal ICB reset
    pub const INDIRECT_COMMAND_BUFFER_RESET: IndirectArgumentType = .{ .bits = 4 };
    /// metal ICB optimization
    pub const INDIRECT_COMMAND_BUFFER_OPTIMIZE: IndirectArgumentType = .{ .bits = 5 };
    pub const INDIRECT_DISPATCH_MESH: IndirectArgumentType = .{ .bits = 6 };

    // pub usingnamespace cpp.FlagsMixin(IndirectArgumentType);
};

///*********************************************
pub const DescriptorType = extern struct {
    bits: c_int = 0,

    pub const DESCRIPTOR_TYPE_UNDEFINED: DescriptorType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const DESCRIPTOR_TYPE_SAMPLER: DescriptorType = .{ .bits = @as(c_uint, @intCast(1)) };
    /// SRV Read only texture
    pub const DESCRIPTOR_TYPE_TEXTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_SAMPLER.bits << 1))) };
    /// UAV Texture
    pub const DESCRIPTOR_TYPE_RW_TEXTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_TEXTURE.bits << 1))) };
    /// SRV Read only buffer
    pub const DESCRIPTOR_TYPE_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_TEXTURE.bits << 1))) };
    /// SRV Read only buffer
    pub const DESCRIPTOR_TYPE_BUFFER_RAW: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits | (DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits << 1)))) };
    /// UAV Buffer
    pub const DESCRIPTOR_TYPE_RW_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_BUFFER.bits << 2))) };
    /// UAV Buffer
    pub const DESCRIPTOR_TYPE_RW_BUFFER_RAW: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits | (DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits << 1)))) };
    /// Uniform buffer
    pub const DESCRIPTOR_TYPE_UNIFORM_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RW_BUFFER.bits << 2))) };
    /// Push constant / Root constant
    pub const DESCRIPTOR_TYPE_ROOT_CONSTANT: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_UNIFORM_BUFFER.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_VERTEX_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_ROOT_CONSTANT.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_INDEX_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_VERTEX_BUFFER.bits << 1))) };
    /// IA
    pub const DESCRIPTOR_TYPE_INDIRECT_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDEX_BUFFER.bits << 1))) };
    /// Cubemap SRV
    pub const DESCRIPTOR_TYPE_TEXTURE_CUBE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_TEXTURE.bits | (DescriptorType.DESCRIPTOR_TYPE_INDIRECT_BUFFER.bits << 1)))) };
    /// RTV / DSV per mip slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDIRECT_BUFFER.bits << 2))) };
    /// RTV / DSV per array slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_MIP_SLICES.bits << 1))) };
    /// RTV / DSV per depth slice
    pub const DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_ARRAY_SLICES.bits << 1))) };
    /// RTV / DSV per depth slice
    pub const DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_RENDER_TARGET_DEPTH_SLICES.bits << 1))) };
    /// Raytracing acceleration structure
    pub const DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE: DescriptorType = .{ .bits = @as(c_uint, @intCast((DescriptorType.DESCRIPTOR_TYPE_INDIRECT_COMMAND_BUFFER.bits << 1))) };

    // pub usingnamespace cpp.FlagsMixin(DescriptorType);
};

///*********************************************
pub const SampleCount = extern struct {
    bits: c_int = 0,

    pub const SAMPLE_COUNT_1: SampleCount = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const SAMPLE_COUNT_2: SampleCount = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const SAMPLE_COUNT_4: SampleCount = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const SAMPLE_COUNT_8: SampleCount = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const SAMPLE_COUNT_16: SampleCount = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const SAMPLE_COUNT_COUNT: SampleCount = .{ .bits = @as(c_uint, @intCast(5)) };
    pub const SAMPLE_COUNT_ALL_BITS: SampleCount = .{ .bits = (@as(u32, @intCast(SampleCount.SAMPLE_COUNT_1.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_2.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_4.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_8.bits)) | @as(u32, @intCast(SampleCount.SAMPLE_COUNT_16.bits))) };

    // pub usingnamespace cpp.FlagsMixin(SampleCount);
};

pub const ShaderStage = extern struct {
    bits: c_int = 0,

    pub const SHADER_STAGE_NONE: ShaderStage = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SHADER_STAGE_VERT: ShaderStage = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const SHADER_STAGE_FRAG: ShaderStage = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const SHADER_STAGE_COMP: ShaderStage = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const SHADER_STAGE_GEOM: ShaderStage = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const SHADER_STAGE_TESC: ShaderStage = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const SHADER_STAGE_TESE: ShaderStage = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const SHADER_STAGE_AMPL: ShaderStage = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const SHADER_STAGE_MESH: ShaderStage = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const SHADER_STAGE_ALL_GRAPHICS: ShaderStage = .{ .bits = (@as(u32, @intCast(ShaderStage.SHADER_STAGE_VERT.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_TESC.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_TESE.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_GEOM.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_FRAG.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_AMPL.bits)) | @as(u32, @intCast(ShaderStage.SHADER_STAGE_MESH.bits))) };
    pub const SHADER_STAGE_HULL: ShaderStage = .{ .bits = @as(c_uint, @intCast(ShaderStage.SHADER_STAGE_TESC.bits)) };
    pub const SHADER_STAGE_DOMN: ShaderStage = .{ .bits = @as(c_uint, @intCast(ShaderStage.SHADER_STAGE_TESE.bits)) };
    pub const SHADER_STAGE_WORKGRAPH: ShaderStage = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const SHADER_STAGE_COUNT: ShaderStage = .{ .bits = @as(c_uint, @intCast(9)) };

    // pub usingnamespace cpp.FlagsMixin(ShaderStage);
};

pub const PrimitiveTopology = extern struct {
    bits: c_int = 0,

    pub const PRIMITIVE_TOPO_POINT_LIST: PrimitiveTopology = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PRIMITIVE_TOPO_LINE_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 1 };
    pub const PRIMITIVE_TOPO_LINE_STRIP: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 2 };
    pub const PRIMITIVE_TOPO_TRI_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 3 };
    pub const PRIMITIVE_TOPO_TRI_STRIP: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 4 };
    pub const PRIMITIVE_TOPO_PATCH_LIST: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 5 };
    pub const PRIMITIVE_TOPO_COUNT: PrimitiveTopology = .{ .bits = PrimitiveTopology.PRIMITIVE_TOPO_POINT_LIST.bits + 6 };

    // pub usingnamespace cpp.FlagsMixin(PrimitiveTopology);
};

pub const IndexType = extern struct {
    bits: c_int = 0,

    pub const INDEX_TYPE_UINT32: IndexType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const INDEX_TYPE_UINT16: IndexType = .{ .bits = IndexType.INDEX_TYPE_UINT32.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(IndexType);
};

pub const ShaderSemantic = extern struct {
    bits: c_int = 0,

    pub const SEMANTIC_UNDEFINED: ShaderSemantic = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SEMANTIC_POSITION: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 1 };
    pub const SEMANTIC_NORMAL: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 2 };
    pub const SEMANTIC_COLOR: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 3 };
    pub const SEMANTIC_TANGENT: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 4 };
    pub const SEMANTIC_BITANGENT: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 5 };
    pub const SEMANTIC_JOINTS: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 6 };
    pub const SEMANTIC_WEIGHTS: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 7 };
    pub const SEMANTIC_CUSTOM: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 8 };
    pub const SEMANTIC_TEXCOORD0: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 9 };
    pub const SEMANTIC_TEXCOORD1: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 10 };
    pub const SEMANTIC_TEXCOORD2: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 11 };
    pub const SEMANTIC_TEXCOORD3: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 12 };
    pub const SEMANTIC_TEXCOORD4: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 13 };
    pub const SEMANTIC_TEXCOORD5: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 14 };
    pub const SEMANTIC_TEXCOORD6: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 15 };
    pub const SEMANTIC_TEXCOORD7: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 16 };
    pub const SEMANTIC_TEXCOORD8: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 17 };
    pub const SEMANTIC_TEXCOORD9: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 18 };
    pub const MAX_SEMANTICS: ShaderSemantic = .{ .bits = ShaderSemantic.SEMANTIC_UNDEFINED.bits + 19 };

    // pub usingnamespace cpp.FlagsMixin(ShaderSemantic);
};

pub const BlendConstant = extern struct {
    bits: c_int = 0,

    pub const BC_ZERO: BlendConstant = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const BC_ONE: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 1 };
    pub const BC_SRC_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 2 };
    pub const BC_ONE_MINUS_SRC_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 3 };
    pub const BC_DST_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 4 };
    pub const BC_ONE_MINUS_DST_COLOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 5 };
    pub const BC_SRC_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 6 };
    pub const BC_ONE_MINUS_SRC_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 7 };
    pub const BC_DST_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 8 };
    pub const BC_ONE_MINUS_DST_ALPHA: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 9 };
    pub const BC_SRC_ALPHA_SATURATE: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 10 };
    pub const BC_BLEND_FACTOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 11 };
    pub const BC_ONE_MINUS_BLEND_FACTOR: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 12 };
    pub const MAX_BLEND_CONSTANTS: BlendConstant = .{ .bits = BlendConstant.BC_ZERO.bits + 13 };

    // pub usingnamespace cpp.FlagsMixin(BlendConstant);
};

pub const BlendMode = extern struct {
    bits: c_int = 0,

    pub const BM_ADD: BlendMode = .{ .bits = 0 };
    pub const BM_SUBTRACT: BlendMode = .{ .bits = 1 };
    pub const BM_REVERSE_SUBTRACT: BlendMode = .{ .bits = 2 };
    pub const BM_MIN: BlendMode = .{ .bits = 3 };
    pub const BM_MAX: BlendMode = .{ .bits = 4 };
    pub const MAX_BLEND_MODES: BlendMode = .{ .bits = 5 };

    // pub usingnamespace cpp.FlagsMixin(BlendMode);
};

pub const CompareMode = extern struct {
    bits: c_int = 0,

    pub const CMP_NEVER: CompareMode = .{ .bits = 0 };
    pub const CMP_LESS: CompareMode = .{ .bits = 1 };
    pub const CMP_EQUAL: CompareMode = .{ .bits = 2 };
    pub const CMP_LEQUAL: CompareMode = .{ .bits = 3 };
    pub const CMP_GREATER: CompareMode = .{ .bits = 4 };
    pub const CMP_NOTEQUAL: CompareMode = .{ .bits = 5 };
    pub const CMP_GEQUAL: CompareMode = .{ .bits = 6 };
    pub const CMP_ALWAYS: CompareMode = .{ .bits = 7 };
    pub const MAX_COMPARE_MODES: CompareMode = .{ .bits = 8 };

    // pub usingnamespace cpp.FlagsMixin(CompareMode);
};

pub const StencilOp = extern struct {
    bits: c_int = 0,

    pub const STENCIL_OP_KEEP: StencilOp = .{ .bits = 0 };
    pub const STENCIL_OP_SET_ZERO: StencilOp = .{ .bits = 1 };
    pub const STENCIL_OP_REPLACE: StencilOp = .{ .bits = 2 };
    pub const STENCIL_OP_INVERT: StencilOp = .{ .bits = 3 };
    pub const STENCIL_OP_INCR: StencilOp = .{ .bits = 4 };
    pub const STENCIL_OP_DECR: StencilOp = .{ .bits = 5 };
    pub const STENCIL_OP_INCR_SAT: StencilOp = .{ .bits = 6 };
    pub const STENCIL_OP_DECR_SAT: StencilOp = .{ .bits = 7 };
    pub const MAX_STENCIL_OPS: StencilOp = .{ .bits = 8 };

    // pub usingnamespace cpp.FlagsMixin(StencilOp);
};

pub const ColorMask = extern struct {
    bits: c_int = 0,

    pub const COLOR_MASK_NONE: ColorMask = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const COLOR_MASK_RED: ColorMask = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const COLOR_MASK_GREEN: ColorMask = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const COLOR_MASK_BLUE: ColorMask = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const COLOR_MASK_ALPHA: ColorMask = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const COLOR_MASK_ALL: ColorMask = .{ .bits = @as(c_uint, @intCast((ColorMask.COLOR_MASK_RED.bits | ColorMask.COLOR_MASK_GREEN.bits | ColorMask.COLOR_MASK_BLUE.bits | ColorMask.COLOR_MASK_ALPHA.bits))) };

    // pub usingnamespace cpp.FlagsMixin(ColorMask);
};

/// Blend states are always attached to one of the eight or more render targets that
/// are in a MRT
/// Mask constants
pub const BlendStateTargets = extern struct {
    bits: c_int = 0,

    pub const BLEND_STATE_TARGET_0: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const BLEND_STATE_TARGET_1: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const BLEND_STATE_TARGET_2: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const BLEND_STATE_TARGET_3: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const BLEND_STATE_TARGET_4: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const BLEND_STATE_TARGET_5: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const BLEND_STATE_TARGET_6: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const BLEND_STATE_TARGET_7: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const BLEND_STATE_TARGET_ALL: BlendStateTargets = .{ .bits = @as(c_uint, @intCast(255)) };

    // pub usingnamespace cpp.FlagsMixin(BlendStateTargets);
};

/// Blend states are always attached to one of the eight or more render targets that
/// are in a MRT
/// Mask constants
pub const CullMode = extern struct {
    bits: c_int = 0,

    pub const CULL_MODE_NONE: CullMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const CULL_MODE_BACK: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 1 };
    pub const CULL_MODE_FRONT: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 2 };
    pub const CULL_MODE_BOTH: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 3 };
    pub const MAX_CULL_MODES: CullMode = .{ .bits = CullMode.CULL_MODE_NONE.bits + 4 };

    // pub usingnamespace cpp.FlagsMixin(CullMode);
};

pub const FrontFace = extern struct {
    bits: c_int = 0,

    pub const FRONT_FACE_CCW: FrontFace = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FRONT_FACE_CW: FrontFace = .{ .bits = FrontFace.FRONT_FACE_CCW.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(FrontFace);
};

pub const FillMode = extern struct {
    bits: c_int = 0,

    pub const FILL_MODE_SOLID: FillMode = .{ .bits = 0 };
    pub const FILL_MODE_WIREFRAME: FillMode = .{ .bits = 1 };
    pub const MAX_FILL_MODES: FillMode = .{ .bits = 2 };

    // pub usingnamespace cpp.FlagsMixin(FillMode);
};

pub const PipelineType = extern struct {
    bits: c_int = 0,

    pub const PIPELINE_TYPE_UNDEFINED: PipelineType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PIPELINE_TYPE_COMPUTE: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 1 };
    pub const PIPELINE_TYPE_GRAPHICS: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 2 };
    pub const PIPELINE_TYPE_WORKGRAPH: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 3 };
    pub const PIPELINE_TYPE_MESH: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 4 };
    pub const PIPELINE_TYPE_COUNT: PipelineType = .{ .bits = PipelineType.PIPELINE_TYPE_UNDEFINED.bits + 5 };

    // pub usingnamespace cpp.FlagsMixin(PipelineType);
};

pub const FilterType = extern struct {
    bits: c_int = 0,

    pub const FILTER_NEAREST: FilterType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FILTER_LINEAR: FilterType = .{ .bits = FilterType.FILTER_NEAREST.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(FilterType);
};

pub const AddressMode = extern struct {
    bits: c_int = 0,

    pub const ADDRESS_MODE_MIRROR: AddressMode = .{ .bits = 0 };
    pub const ADDRESS_MODE_REPEAT: AddressMode = .{ .bits = 1 };
    pub const ADDRESS_MODE_CLAMP_TO_EDGE: AddressMode = .{ .bits = 2 };
    pub const ADDRESS_MODE_CLAMP_TO_BORDER: AddressMode = .{ .bits = 3 };

    // pub usingnamespace cpp.FlagsMixin(AddressMode);
};

pub const MipMapMode = extern struct {
    bits: c_int = 0,

    pub const MIPMAP_MODE_NEAREST: MipMapMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const MIPMAP_MODE_LINEAR: MipMapMode = .{ .bits = MipMapMode.MIPMAP_MODE_NEAREST.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(MipMapMode);
};

pub const ClearValue = extern union {
    __struct_field1: __Struct0,
    __struct_field3: __Struct2,

    pub const __Struct0 = extern struct {
        r: f32,
        g: f32,
        b: f32,
        a: f32,
    };

    pub const __Struct2 = extern struct {
        depth: f32,
        stencil: u32,
    };
};

pub const BufferCreationFlags = extern struct {
    bits: c_int = 0,

    /// Default flag (Buffer will use aliased memory, buffer will not be cpu accessible until mapBuffer is called)
    pub const BUFFER_CREATION_FLAG_NONE: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Buffer will allocate its own memory (COMMITTED resource)
    pub const BUFFER_CREATION_FLAG_OWN_MEMORY_BIT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Buffer will be persistently mapped
    pub const BUFFER_CREATION_FLAG_PERSISTENT_MAP_BIT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Use ESRAM to store this buffer
    pub const BUFFER_CREATION_FLAG_ESRAM: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_NO_DESCRIPTOR_VIEW_CREATION: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_ACCELERATION_STRUCTURE_BUILD_INPUT: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_SHADER_DEVICE_ADDRESS: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_SHADER_BINDING_TABLE: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Flag to specify not to allocate descriptors for the resource
    pub const BUFFER_CREATION_FLAG_MARKER: BufferCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };

    // pub usingnamespace cpp.FlagsMixin(BufferCreationFlags);
};

pub const TextureCreationFlags = extern struct {
    bits: c_int = 0,

    /// Default flag (Texture will use default allocation strategy decided by the api specific allocator)
    pub const TEXTURE_CREATION_FLAG_NONE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Texture will allocate its own memory (COMMITTED resource)
    pub const TEXTURE_CREATION_FLAG_OWN_MEMORY_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Texture will be allocated in memory which can be shared among multiple processes
    pub const TEXTURE_CREATION_FLAG_EXPORT_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// Texture will be allocated in memory which can be shared among multiple gpus
    pub const TEXTURE_CREATION_FLAG_EXPORT_ADAPTER_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Texture will be imported from a handle created in another process
    pub const TEXTURE_CREATION_FLAG_IMPORT_BIT: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Use ESRAM to store this texture
    pub const TEXTURE_CREATION_FLAG_ESRAM: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    /// Use on-tile memory to store this texture
    pub const TEXTURE_CREATION_FLAG_ON_TILE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    /// Prevent compression meta data from generating (XBox)
    pub const TEXTURE_CREATION_FLAG_NO_COMPRESSION: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Force 2D instead of automatically determining dimension based on width, height, depth
    pub const TEXTURE_CREATION_FLAG_FORCE_2D: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Force 3D instead of automatically determining dimension based on width, height, depth
    pub const TEXTURE_CREATION_FLAG_FORCE_3D: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    /// Display target
    pub const TEXTURE_CREATION_FLAG_ALLOW_DISPLAY_TARGET: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(512)) };
    /// Create an sRGB texture.
    pub const TEXTURE_CREATION_FLAG_SRGB: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(1024)) };
    /// Create a normal map texture
    pub const TEXTURE_CREATION_FLAG_NORMAL_MAP: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(2048)) };
    /// Fast clear
    pub const TEXTURE_CREATION_FLAG_FAST_CLEAR: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(4096)) };
    /// Fragment mask
    pub const TEXTURE_CREATION_FLAG_FRAG_MASK: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(8192)) };
    /// Doubles the amount of array layers of the texture when rendering VR. Also forces the texture to be a 2D Array texture.
    pub const TEXTURE_CREATION_FLAG_VR_MULTIVIEW: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(16384)) };
    /// Binds the FFR fragment density if this texture is used as a render target.
    pub const TEXTURE_CREATION_FLAG_VR_FOVEATED_RENDERING: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(32768)) };
    pub const TEXTURE_CREATION_FLAG_SAMPLE_LOCATIONS_COMPATIBLE: TextureCreationFlags = .{ .bits = @as(c_uint, @intCast(131072)) };

    // pub usingnamespace cpp.FlagsMixin(TextureCreationFlags);
};

/// Used for swapchain
pub const ColorSpace = extern struct {
    bits: c_int = 0,

    pub const COLOR_SPACE_SDR_LINEAR: ColorSpace = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const COLOR_SPACE_SDR_SRGB: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 1 };
    /// BT2020 color space with PQ EOTF
    pub const COLOR_SPACE_P2020: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 2 };
    /// Extended sRGB with linear EOTF
    pub const COLOR_SPACE_EXTENDED_SRGB: ColorSpace = .{ .bits = ColorSpace.COLOR_SPACE_SDR_LINEAR.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(ColorSpace);
};

/// Used for swapchain
pub const BufferBarrier = extern struct {
    pBuffer: [*c]Buffer,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        /// Padding added by c2z
        _dummy_padding: u6,
    },

    // TIDES: BEGIN MANUAL CHANGES
    pub fn init(buffer: [*c]Buffer, current_state: ResourceState, new_state: ResourceState) BufferBarrier {
        var barrier = std.mem.zeroes(BufferBarrier);
        barrier.pBuffer = buffer;
        barrier.mCurrentState = current_state;
        barrier.mNewState = new_state;

        return barrier;
    }
    // TIDES: END MANUAL CHANGES
};

pub const TextureBarrier = extern struct {
    pTexture: [*c]Texture,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        mAcquire: u1, // 3 bits
        mRelease: u1, // 4 bits
        /// Padding added by c2z
        _dummy_padding: u4,
    },

    bitfield_2: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mQueueType: u5, // 5 bits
        /// Specifiy whether following barrier targets particular subresource
        mSubresourceBarrier: u1, // 6 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_3: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Following values are ignored if mSubresourceBarrier is false
        mMipLevel: u7, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    mArrayLayer: u16,

    // TIDES: BEGIN MANUAL CHANGES
    pub fn init(texture: [*c]Texture, current_state: ResourceState, new_state: ResourceState) TextureBarrier {
        var barrier = std.mem.zeroes(TextureBarrier);
        barrier.pTexture = texture;
        barrier.mCurrentState = current_state;
        barrier.mNewState = new_state;

        return barrier;
    }
    // TIDES: END MANUAL CHANGES
};

pub const RenderTargetBarrier = extern struct {
    pRenderTarget: [*c]RenderTarget,
    mCurrentState: ResourceState,
    mNewState: ResourceState,
    bitfield_1: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mBeginOnly: u1, // 1 bits
        mEndOnly: u1, // 2 bits
        mAcquire: u1, // 3 bits
        mRelease: u1, // 4 bits
        /// Padding added by c2z
        _dummy_padding: u4,
    },

    bitfield_2: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mQueueType: u5, // 5 bits
        /// Specifiy whether following barrier targets particular subresource
        mSubresourceBarrier: u1, // 6 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_3: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Following values are ignored if mSubresourceBarrier is false
        mMipLevel: u7, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    mArrayLayer: u16,

    // TIDES: BEGIN MANUAL CHANGES
    pub fn init(render_target: [*c]RenderTarget, current_state: ResourceState, new_state: ResourceState) RenderTargetBarrier {
        var barrier = std.mem.zeroes(RenderTargetBarrier);
        barrier.pRenderTarget = render_target;
        barrier.mCurrentState = current_state;
        barrier.mNewState = new_state;

        return barrier;
    }
    // TIDES: END MANUAL CHANGES
};

pub const ReadRange = extern struct {
    mOffset: u64,
    mSize: u64,
};

pub const QueryType = extern struct {
    bits: c_int = 0,

    pub const QUERY_TYPE_TIMESTAMP: QueryType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const QUERY_TYPE_OCCLUSION: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 1 };
    pub const QUERY_TYPE_PIPELINE_STATISTICS: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 2 };
    pub const QUERY_TYPE_COUNT: QueryType = .{ .bits = QueryType.QUERY_TYPE_TIMESTAMP.bits + 3 };

    // pub usingnamespace cpp.FlagsMixin(QueryType);
};

pub const QueryPoolDesc = extern struct {
    pName: [*c]const u8,
    mType: QueryType,
    mQueryCount: u32,
    mNodeIndex: u32,
};

pub const QueryDesc = extern struct {
    mIndex: u32,
};

pub const QueryPool = extern struct {
    mDx: __Struct0,
    mCount: u32,
    mStride: u32,

    pub const __Struct0 = extern struct {
        pQueryHeap: *ID3D12QueryHeap,
        pReadbackBuffer: [*c]Buffer,
        mType: D3D12_QUERY_TYPE,
    };
};

pub const PipelineStatisticsQueryData = extern struct {
    mIAVertices: u64,
    mIAPrimitives: u64,
    mVSInvocations: u64,
    mGSInvocations: u64,
    mGSPrimitives: u64,
    mCInvocations: u64,
    mCPrimitives: u64,
    mPSInvocations: u64,
    mHSInvocations: u64,
    mDSInvocations: u64,
    mCSInvocations: u64,
};

pub const QueryData = extern struct {
    __union_field1: __Union0,
    mValid: bool,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,
        mOcclusionCounts: u64,

        pub const __Struct0 = extern struct {
            mPipelineStats: PipelineStatisticsQueryData,
        };

        pub const __Struct2 = extern struct {
            mBeginTimestamp: u64,
            mEndTimestamp: u64,
        };
    };
};

pub const ResourceHeapCreationFlags = extern struct {
    bits: c_int = 0,

    pub const RESOURCE_HEAP_FLAG_NONE: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const RESOURCE_HEAP_FLAG_SHARED: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const RESOURCE_HEAP_FLAG_DENY_BUFFERS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_DISPLAY: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const RESOURCE_HEAP_FLAG_SHARED_CROSS_ADAPTER: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const RESOURCE_HEAP_FLAG_HARDWARE_PROTECTED: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_WRITE_WATCH: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const RESOURCE_HEAP_FLAG_ALLOW_SHADER_ATOMICS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(512)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_BUFFERS: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES.bits)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_BUFFERS.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_RT_DS_TEXTURES.bits)) };
    /// These are convenience aliases to manage resource heap tier restrictions. They cannot be bitwise OR'ed together cleanly.
    pub const RESOURCE_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES: ResourceHeapCreationFlags = .{ .bits = @as(c_uint, @intCast(ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_BUFFERS.bits | ResourceHeapCreationFlags.RESOURCE_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES.bits)) };

    // pub usingnamespace cpp.FlagsMixin(ResourceHeapCreationFlags);
};

pub const ResourceHeapDesc = extern struct {
    mSize: u64,
    mAlignment: u64,
    mMemoryUsage: ResourceMemoryUsage,
    mDescriptors: DescriptorType,
    mFlags: ResourceHeapCreationFlags,
    mNodeIndex: u32,
    mSharedNodeIndexCount: u32,
    pSharedNodeIndices: [*c]u32,
    pName: [*c]const u8,
};

pub const ResourceHeap = extern struct {
    mDx: __Struct0,
    mSize: u64,

    pub const __Struct0 = extern struct {
        pHeap: *ID3D12Heap,
    };
};

pub const ResourceSizeAlign = extern struct {
    mSize: u64,
    mAlignment: u64,
};

pub const ResourcePlacement = extern struct {
    pHeap: [*c]ResourceHeap,
    mOffset: u64,
};

/// Data structure holding necessary info to create a Buffer
pub const BufferDesc = extern struct {
    /// Optional placement (addBuffer will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Size of the buffer (in bytes)
    mSize: u64,
    /// Set this to specify a counter buffer for this buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    pCounterBuffer: [*c]Buffer,
    /// Index of the first element accessible by the SRV/UAV (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mFirstElement: u32,
    /// Number of elements in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mElementCount: u32,
    /// Size of each element (in bytes) in the buffer (applicable to BUFFER_USAGE_STORAGE_SRV, BUFFER_USAGE_STORAGE_UAV)
    mStructStride: u32,
    /// Alignment
    mAlignment: u32,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    pSharedNodeIndices: [*c]u32,
    /// Decides which memory heap buffer will use (default, upload, readback)
    mMemoryUsage: ResourceMemoryUsage,
    /// Creation flags of the buffer
    mFlags: BufferCreationFlags,
    /// What type of queue the buffer is owned by
    mQueueType: QueueType,
    /// What state will the buffer get created in
    mStartState: ResourceState,
    /// ICB draw type
    mICBDrawType: IndirectArgumentType,
    /// ICB max commands in indirect command buffer
    mICBMaxCommandCount: u32,
    /// Format of the buffer (applicable to typed storage buffers (Buffer
    ///<T
    ///>)
    mFormat: TinyImageFormat,
    /// Flags specifying the suitable usage of this buffer (Uniform buffer, Vertex Buffer, Index Buffer,...)
    mDescriptors: DescriptorType,
    /// The index of the GPU in SLI/Cross-Fire that owns this buffer, or the Renderer index in unlinked mode.
    mNodeIndex: u32,
    mSharedNodeIndexCount: u32,
    bBindless: bool,
};

/// Data structure holding necessary info to create a Buffer
pub const Buffer = extern struct {
    /// CPU address of the mapped buffer (applicable to buffers created in CPU accessible heaps (CPU, CPU_TO_GPU, GPU_TO_CPU)
    pCpuMappedAddress: ?*anyopaque,
    mDx: __Struct0,
    bitfield_1: packed struct(u64) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSize: u32, // 32 bits
        mDescriptors: u20, // 52 bits
        mMemoryUsage: u3, // 55 bits
        mNodeIndex: u4, // 59 bits
        /// Padding added by c2z
        _dummy_padding: u5,
    },

    pub const __Struct0 = extern struct {
        /// GPU Address - Cache to avoid calls to ID3D12Resource::GetGpuVirtualAddress
        mGpuAddress: D3D12_GPU_VIRTUAL_ADDRESS,
        /// Descriptor handle of the CBV in a CPU visible descriptor heap (applicable to BUFFER_USAGE_UNIFORM)
        mDescriptors: DxDescriptorID,
        /// Offset from mDescriptors for srv descriptor handle
        mSrvDescriptorOffset: u8,
        /// Offset from mDescriptors for uav descriptor handle
        mUavDescriptorOffset: u8,
        bitfield_1: packed struct(u8) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mMarkerBuffer: u1, // 1 bits
            /// Padding added by c2z
            _dummy_padding: u7,
        },

        /// Native handle of the underlying resource
        pResource: *ID3D12Resource,
        __union_field1: __Union0,

        pub const __Union0 = extern union {
            pMarkerBufferHeap: *ID3D12Heap,
            /// Contains resource allocation info such as parent heap, offset in heap
            pAllocation: *D3D12MAAllocation,
        };
    };
};

/// Data structure holding necessary info to create a Texture
pub const TextureDesc = extern struct {
    /// Optional placement (addTexture will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Optimized clear value (recommended to use this same value when clearing the rendertarget)
    mClearValue: ClearValue,
    /// Pointer to native texture handle if the texture does not own underlying resource
    pNativeHandle: ?*const anyopaque,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    /// GPU indices to share this texture
    pSharedNodeIndices: [*c]u32,
    /// Texture creation flags (decides memory allocation strategy, sharing access,...)
    mFlags: TextureCreationFlags,
    /// Width
    mWidth: u32,
    /// Height
    mHeight: u32,
    /// Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)
    mDepth: u32,
    /// Texture array size (Should be 1 if texture is not a texture array or cubemap)
    mArraySize: u32,
    /// Number of mip levels
    mMipLevels: u32,
    /// Number of multisamples per pixel (currently Textures created with mUsage TEXTURE_USAGE_SAMPLED_IMAGE only support SAMPLE_COUNT_1)
    mSampleCount: SampleCount,
    /// The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value
    /// appropriate for mSampleCount
    mSampleQuality: u32,
    ///  image format
    mFormat: TinyImageFormat,
    /// What state will the texture get created in
    mStartState: ResourceState,
    /// Descriptor creation
    mDescriptors: DescriptorType,
    /// Number of GPUs to share this texture
    mSharedNodeIndexCount: u32,
    /// GPU which will own this texture
    mNodeIndex: u32,
    bBindless: bool,
};

/// Data structure holding necessary info to create a Texture
pub const Texture = extern struct {
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Current state of the buffer
        mWidth: u16, // 16 bits
        mHeight: u16, // 32 bits
    },

    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mDepth: u16, // 16 bits
        mMipLevels: u5, // 21 bits
        mArraySizeMinusOne: u11, // 32 bits
    },

    bitfield_3: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mFormat: u8, // 8 bits
        /// Flags specifying which aspects (COLOR,DEPTH,STENCIL) are included in the pImageView
        mAspectMask: u4, // 12 bits
        mNodeIndex: u4, // 16 bits
        mSampleCount: u5, // 21 bits
        mUav: u1, // 22 bits
        /// This value will be false if the underlying resource is not owned by the texture (swapchain textures,...)
        mOwnsImage: u1, // 23 bits
        /// Only applies to Vulkan but kept here as adding it inside mVk block increases the size of the struct and triggers assert below
        mLazilyAllocated: u1, // 24 bits
        /// Padding added by c2z
        _dummy_padding: u8,
    },

    pub const __Struct0 = extern struct {
        /// Descriptor handle of the SRV in a CPU visible descriptor heap (applicable to TEXTURE_USAGE_SAMPLED_IMAGE)
        mDescriptors: DxDescriptorID,
        /// Native handle of the underlying resource
        pResource: *ID3D12Resource,
        /// Contains resource allocation info such as parent heap, offset in heap
        pAllocation: *D3D12MAAllocation,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mHandleCount: u24, // 24 bits
            /// Padding added by c2z
            _dummy_padding: u8,
        },

        mUavStartIndex: u32,
    };
};

pub const RenderTargetDesc = extern struct {
    /// Optional placement (addRenderTarget will place/bind buffer in this memory instead of allocating space)
    pPlacement: [*c]ResourcePlacement,
    /// Texture creation flags (decides memory allocation strategy, sharing access,...)
    mFlags: TextureCreationFlags,
    /// Width
    mWidth: u32,
    /// Height
    mHeight: u32,
    /// Depth (Should be 1 if not a mType is not TEXTURE_TYPE_3D)
    mDepth: u32,
    /// Texture array size (Should be 1 if texture is not a texture array or cubemap)
    mArraySize: u32,
    /// Number of mip levels
    mMipLevels: u32,
    /// MSAA
    mSampleCount: SampleCount,
    /// Internal image format
    mFormat: TinyImageFormat,
    /// What state will the texture get created in
    mStartState: ResourceState,
    /// Optimized clear value (recommended to use this same value when clearing the rendertarget)
    mClearValue: ClearValue,
    /// The image quality level. The higher the quality, the lower the performance. The valid range is between zero and the value
    /// appropriate for mSampleCount
    mSampleQuality: u32,
    /// Descriptor creation
    mDescriptors: DescriptorType,
    pNativeHandle: ?*const anyopaque,
    /// Debug name used in gpu profile
    pName: [*c]const u8,
    /// GPU indices to share this texture
    pSharedNodeIndices: [*c]u32,
    /// Number of GPUs to share this texture
    mSharedNodeIndexCount: u32,
    /// GPU which will own this texture
    mNodeIndex: u32,
};

pub const RenderTarget = extern struct {
    pTexture: [*c]Texture,
    mDx: __Struct0,
    mClearValue: ClearValue,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mArraySize: u16, // 16 bits
        mDepth: u16, // 32 bits
    },

    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mWidth: u16, // 16 bits
        mHeight: u16, // 32 bits
    },

    bitfield_3: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mDescriptors: u20, // 20 bits
        mMipLevels: u10, // 30 bits
        /// Padding added by c2z
        _dummy_padding: u2,
    },

    bitfield_4: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSampleQuality: u5, // 5 bits
        /// Padding added by c2z
        _dummy_padding: u27,
    },

    mFormat: TinyImageFormat,
    mSampleCount: SampleCount,
    mVRMultiview: bool,
    mVRFoveatedRendering: bool,

    pub const __Struct0 = extern struct {
        mDescriptors: DxDescriptorID,
    };
};

pub const SampleLocations = extern struct {
    mX: i8,
    mY: i8,
};

pub const SamplerDesc = extern struct {
    mMinFilter: FilterType,
    mMagFilter: FilterType,
    mMipMapMode: MipMapMode,
    mAddressU: AddressMode,
    mAddressV: AddressMode,
    mAddressW: AddressMode,
    mMipLodBias: f32,
    mSetLodRange: bool,
    mMinLod: f32,
    mMaxLod: f32,
    mMaxAnisotropy: f32,
    mCompareFunc: CompareMode,
};

pub const Sampler = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        /// Description for creating the Sampler descriptor for this sampler
        mDesc: D3D12_SAMPLER_DESC,
        /// Descriptor handle of the Sampler in a CPU visible descriptor heap
        mDescriptor: DxDescriptorID,
    };
};

pub const DescriptorUpdateFrequency = extern struct {
    bits: c_int = 0,

    pub const DESCRIPTOR_UPDATE_FREQ_NONE: DescriptorUpdateFrequency = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const DESCRIPTOR_UPDATE_FREQ_PER_FRAME: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 1 };
    pub const DESCRIPTOR_UPDATE_FREQ_PER_BATCH: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 2 };
    pub const DESCRIPTOR_UPDATE_FREQ_PER_DRAW: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 3 };
    pub const DESCRIPTOR_UPDATE_FREQ_COUNT: DescriptorUpdateFrequency = .{ .bits = DescriptorUpdateFrequency.DESCRIPTOR_UPDATE_FREQ_NONE.bits + 4 };

    // pub usingnamespace cpp.FlagsMixin(DescriptorUpdateFrequency);
};

/// Data structure holding the layout for a descriptor
pub const DescriptorInfo = extern struct {
    pName: [*c]const u8,
    mType: u32,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mDim: u4, // 4 bits
        mRootDescriptor: u1, // 5 bits
        mStaticSampler: u1, // 6 bits
        mUpdateFrequency: u3, // 9 bits
        /// Padding added by c2z
        _dummy_padding: u23,
    },

    mSize: u32,
    mHandleIndex: u32,
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        mPadA: u64,
    };
};

/// Data structure holding the layout for a descriptor
pub const RootSignatureFlags = extern struct {
    bits: c_int = 0,

    /// Default flag
    pub const ROOT_SIGNATURE_FLAG_NONE: RootSignatureFlags = .{ .bits = @as(c_uint, @intCast(0)) };

    // pub usingnamespace cpp.FlagsMixin(RootSignatureFlags);
};

pub const RootSignatureDesc = extern struct {
    ppShaders: [*c][*c]Shader,
    mShaderCount: u32,
    mMaxBindlessTextures: u32,
    ppStaticSamplerNames: [*c]const [*c]u8,
    ppStaticSamplers: [*c][*c]Sampler,
    mStaticSamplerCount: u32,
    mFlags: RootSignatureFlags,
};

pub const RootSignature = extern struct {
    /// Number of descriptors declared in the root signature layout
    mDescriptorCount: u32,
    /// Graphics or Compute
    mPipelineType: PipelineType,
    /// Array of all descriptors declared in the root signature layout
    pDescriptors: [*c]DescriptorInfo,
    /// Translates hash of descriptor name to descriptor index in pDescriptors array
    pDescriptorNameToIndexMap: *DescriptorIndexMap,
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pRootSignature: *ID3D12RootSignature,
        mViewDescriptorTableRootIndices: [4]u8,
        mSamplerDescriptorTableRootIndices: [4]u8,
        mCumulativeViewDescriptorCounts: [4]u32,
        mCumulativeSamplerDescriptorCounts: [4]u32,
        mViewDescriptorCounts: [4]u16,
        mSamplerDescriptorCounts: [4]u16,
        mHasRayQueryAccelerationStructure: bool,
    };
};

pub const DescriptorDataRange = extern struct {
    mOffset: u32,
    mSize: u32,
    /// Specify different structured buffer stride (ignored for raw buffer - ByteAddressBuffer)
    mStructStride: u32,
};

pub const DescriptorData = extern struct {
    /// User can either set name of descriptor or index (index in pRootSignature->pDescriptors array)
    /// Name of descriptor
    pName: [*c]const u8,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Number of array entries to update (array size of ppTextures/ppBuffers/...)
        mCount: u31, // 31 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Dst offset into the array descriptor (useful for updating few entries in a large array)
        /// Example: to update 6th entry in a bindless texture descriptor, mArrayOffset will be 6 and mCount will be 1)
        mArrayOffset: u20, // 20 bits
        /// Index in pRootSignature->pDescriptors array - Cache index using getDescriptorIndexFromName to avoid using string checks at runtime
        mIndex: u10, // 30 bits
        mBindByIndex: u1, // 31 bits
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    /// Range to bind (buffer offset, size)
    pRanges: [*c]DescriptorDataRange,
    bitfield_3: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Binds stencil only descriptor instead of color/depth
        mBindStencilResource: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u7,
    },

    __union_field1: __Union0,
    __union_field3: __Union2,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,

        pub const __Struct0 = extern struct {
            /// When binding UAV, control the mip slice to to bind for UAV (example - generating mipmaps in a compute shader)
            mUAVMipSlice: u16,
            /// Binds entire mip chain as array of UAV
            mBindMipChain: bool,
        };

        pub const __Struct2 = extern struct {
            /// Bind MTLIndirectCommandBuffer along with the MTLBuffer
            pICBName: [*c]const u8,
            mICBIndex: u32,
            mBindICB: bool,
        };
    };

    /// Array of resources containing descriptor handles or constant to be used in ring buffer memory - DescriptorRange can hold only one
    /// resource type array
    pub const __Union2 = extern union {
        /// Array of texture descriptors (srv and uav textures)
        ppTextures: [*c][*c]Texture,
        /// Array of sampler descriptors
        ppSamplers: [*c][*c]Sampler,
        /// Array of buffer descriptors (srv, uav and cbv buffers)
        ppBuffers: [*c][*c]Buffer,
        /// Custom binding (raytracing acceleration structure ...)
        ppAccelerationStructures: [*c]*AccelerationStructure,
    };
};

pub const DescriptorSet = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        /// Start handle to cbv srv uav descriptor table
        mCbvSrvUavHandle: DxDescriptorID,
        /// Start handle to sampler descriptor table
        mSamplerHandle: DxDescriptorID,
        /// Stride of the cbv srv uav descriptor table (number of descriptors * descriptor size)
        mCbvSrvUavStride: u32,
        /// Stride of the sampler descriptor table (number of descriptors * descriptor size)
        mSamplerStride: u32,
        pRootSignature: [*c]const RootSignature,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mMaxSets: u16, // 16 bits
            mUpdateFrequency: u3, // 19 bits
            mNodeIndex: u4, // 23 bits
            mCbvSrvUavRootIndex: u4, // 27 bits
            mSamplerRootIndex: u4, // 31 bits
            /// Padding added by c2z
            _dummy_padding: u1,
        },

        bitfield_2: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mPipelineType: u3, // 3 bits
            /// Padding added by c2z
            _dummy_padding: u29,
        },
    };
};

pub const CmdPoolDesc = extern struct {
    pQueue: [*c]Queue,
    mTransient: bool,
};

pub const CmdPool = extern struct {
    pCmdAlloc: *ID3D12CommandAllocator,
    pQueue: [*c]Queue,
};

pub const CmdDesc = extern struct {
    pPool: [*c]CmdPool,
    mSecondary: bool,
    pName: [*c]const u8,
};

pub const MarkerFlags = extern struct {
    bits: c_int = 0,

    /// Default flag
    pub const MARKER_FLAG_NONE: MarkerFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    /// Default flag
    pub const MARKER_FLAG_WAIT_FOR_WRITE: MarkerFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(MarkerFlags);
};

pub const MarkerDesc = extern struct {
    pBuffer: [*c]Buffer,
    mOffset: u32,
    mValue: u32,
    mFlags: MarkerFlags,
};

pub const Cmd = extern struct {
    mDx: __Struct0,
    pRenderer: [*c]Renderer,
    pQueue: [*c]Queue,

    pub const __Struct0 = extern struct {
        pCmdList: *ID3D12GraphicsCommandList1,
        /// For resource state validation
        pDebugCmdList: *ID3D12DebugCommandList,
        /// Cached in beginCmd to avoid fetching them during rendering
        pBoundHeaps: [2]*DescriptorHeap,
        mBoundHeapStartHandles: [2]D3D12_GPU_DESCRIPTOR_HANDLE,
        /// Command buffer state
        pBoundRootSignature: [*c]const RootSignature,
        pBoundDescriptorSets: [4][*c]DescriptorSet,
        mBoundDescriptorSetIndices: [4]u16,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            mNodeIndex: u4, // 4 bits
            mType: u3, // 7 bits
            /// Padding added by c2z
            _dummy_padding: u25,
        },

        pCmdPool: [*c]CmdPool,

        // opaques

        // TIDES: BEGIN MANUAL CHANGES
        // const DescriptorHeap = anyopaque;
        // END: BEGIN MANUAL CHANGES
    };
};

pub const FenceStatus = extern struct {
    bits: c_int = 0,

    pub const FENCE_STATUS_COMPLETE: FenceStatus = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FENCE_STATUS_INCOMPLETE: FenceStatus = .{ .bits = FenceStatus.FENCE_STATUS_COMPLETE.bits + 1 };
    pub const FENCE_STATUS_NOTSUBMITTED: FenceStatus = .{ .bits = FenceStatus.FENCE_STATUS_COMPLETE.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(FenceStatus);
};

pub const Fence = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pFence: *ID3D12Fence,
        pWaitIdleFenceEvent: HANDLE,
        mFenceValue: u64,
    };
};

pub const Semaphore = extern struct {
    mDx: __Struct0,

    /// queuePresent does not use the wait semaphore since the swapchain Present function
    /// already does the synchronization in this case
    pub const __Struct0 = extern struct {
        pFence: *ID3D12Fence,
        pWaitIdleFenceEvent: HANDLE,
        mFenceValue: u64,
    };
};

pub const QueueDesc = extern struct {
    mType: QueueType,
    mFlag: QueueFlag,
    mPriority: QueuePriority,
    mNodeIndex: u32,
    pName: [*c]const u8,
};

pub const Queue = extern struct {
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mType: u3, // 3 bits
        mNodeIndex: u4, // 7 bits
        /// Padding added by c2z
        _dummy_padding: u25,
    },

    pub const __Struct0 = extern struct {
        pQueue: *ID3D12CommandQueue,
        pFence: *Fence,
        /// To silence mismatching command list on Windows 11 multi GPU
        pRenderer: [*c]Renderer,
    };
};

/// ShaderConstant only supported by Vulkan and Metal APIs
pub const ShaderConstant = extern struct {
    pValue: ?*const anyopaque,
    mIndex: u32,
    mSize: u32,
};

/// ShaderConstant only supported by Vulkan and Metal APIs
pub const BinaryShaderStageDesc = extern struct {
    pName: [*c]const u8,
    /// Byte code array
    pByteCode: ?*anyopaque,
    mByteCodeSize: u32,
    pEntryPoint: [*c]const u8,
};

pub const BinaryShaderDesc = extern struct {
    mStages: ShaderStage,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Specify whether shader will own byte code memory
        mOwnByteCode: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u31,
    },

    mVert: BinaryShaderStageDesc,
    mFrag: BinaryShaderStageDesc,
    mGeom: BinaryShaderStageDesc,
    mHull: BinaryShaderStageDesc,
    mDomain: BinaryShaderStageDesc,
    mComp: BinaryShaderStageDesc,
    mAmplification: BinaryShaderStageDesc,
    mMesh: BinaryShaderStageDesc,
    pConstants: [*c]const ShaderConstant,
    mConstantCount: u32,
};

pub const Shader = extern struct {
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mStages: u31, // 31 bits
        /// C2Z WARNING: This perhaps shouldn't be padded in this way!
        /// Padding added by c2z
        _dummy_padding: u1,
    },

    bitfield_2: packed struct(u8) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mIsMultiviewVR: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u7,
    },

    mNumThreadsPerGroup: [3]u32,
    mOutputRenderTargetTypesMask: u32,
    mDx: __Struct0,
    pReflection: *PipelineReflection,

    pub const __Struct0 = extern struct {
        pShaderBlobs: [*c]*IDxcBlobEncoding,
        pEntryNames: [*c]LPCWSTR,
    };
};

pub const BlendStateDesc = extern struct {
    /// Source blend factor per render target.
    mSrcFactors: [8]BlendConstant,
    /// Destination blend factor per render target.
    mDstFactors: [8]BlendConstant,
    /// Source alpha blend factor per render target.
    mSrcAlphaFactors: [8]BlendConstant,
    /// Destination alpha blend factor per render target.
    mDstAlphaFactors: [8]BlendConstant,
    /// Blend mode per render target.
    mBlendModes: [8]BlendMode,
    /// Alpha blend mode per render target.
    mBlendAlphaModes: [8]BlendMode,
    /// Write mask per render target.
    mColorWriteMasks: [8]ColorMask,
    /// Mask that identifies the render targets affected by the blend state.
    mRenderTargetMask: BlendStateTargets,
    /// Set whether alpha to coverage should be enabled.
    mAlphaToCoverage: bool,
    /// Set whether each render target has an unique blend function. When false the blend function in slot 0 will be used for all render
    /// targets.
    mIndependentBlend: bool,
};

pub const DepthStateDesc = extern struct {
    mDepthTest: bool,
    mDepthWrite: bool,
    mDepthFunc: CompareMode,
    mStencilTest: bool,
    mStencilReadMask: u8,
    mStencilWriteMask: u8,
    mStencilFrontFunc: CompareMode,
    mStencilFrontFail: StencilOp,
    mDepthFrontFail: StencilOp,
    mStencilFrontPass: StencilOp,
    mStencilBackFunc: CompareMode,
    mStencilBackFail: StencilOp,
    mDepthBackFail: StencilOp,
    mStencilBackPass: StencilOp,
};

pub const RasterizerStateDesc = extern struct {
    mCullMode: CullMode,
    mDepthBias: i32,
    mSlopeScaledDepthBias: f32,
    mFillMode: FillMode,
    mFrontFace: FrontFace,
    mMultiSample: bool,
    mScissor: bool,
    mDepthClampEnable: bool,
};

pub const VertexBindingRate = extern struct {
    bits: c_int = 0,

    pub const VERTEX_BINDING_RATE_VERTEX: VertexBindingRate = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const VERTEX_BINDING_RATE_INSTANCE: VertexBindingRate = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const VERTEX_BINDING_RATE_COUNT: VertexBindingRate = .{ .bits = VertexBindingRate.VERTEX_BINDING_RATE_INSTANCE.bits + 1 };

    // pub usingnamespace cpp.FlagsMixin(VertexBindingRate);
};

pub const VertexBinding = extern struct {
    mStride: u32,
    mRate: VertexBindingRate,
};

pub const VertexAttrib = extern struct {
    mSemantic: ShaderSemantic,
    mSemanticNameLength: u32,
    mSemanticName: [128]u8,
    mFormat: TinyImageFormat,
    mBinding: u32,
    mLocation: u32,
    mOffset: u32,
};

pub const VertexLayout = extern struct {
    mBindings: [15]VertexBinding,
    mAttribs: [15]VertexAttrib,
    mBindingCount: u32,
    mAttribCount: u32,
};

pub const GraphicsPipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pRootSignature: [*c]RootSignature,
    pVertexLayout: [*c]VertexLayout,
    pBlendState: [*c]BlendStateDesc,
    pDepthState: [*c]DepthStateDesc,
    pRasterizerState: [*c]RasterizerStateDesc,
    pColorFormats: [*c]TinyImageFormat,
    mRenderTargetCount: u32,
    mSampleCount: SampleCount,
    mSampleQuality: u32,
    mDepthStencilFormat: TinyImageFormat,
    mPrimitiveTopo: PrimitiveTopology,
    mSupportIndirectCommandBuffer: bool,
    mVRFoveatedRendering: bool,
    mUseCustomSampleLocations: bool,
};

pub const ComputePipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pRootSignature: [*c]RootSignature,
};

pub const MeshPipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pRootSignature: [*c]RootSignature,
    pBlendState: [*c]BlendStateDesc,
    pDepthState: [*c]DepthStateDesc,
    pRasterizerState: [*c]RasterizerStateDesc,
    pColorFormats: [*c]TinyImageFormat,
    mRenderTargetCount: u32,
    mSampleCount: SampleCount,
    mSampleQuality: u32,
    mDepthStencilFormat: TinyImageFormat,
    mPrimitiveTopo: PrimitiveTopology,
    mSupportIndirectCommandBuffer: bool,
    mVRFoveatedRendering: bool,
    mUseCustomSampleLocations: bool,
};

pub const WorkgraphPipelineDesc = extern struct {
    pShaderProgram: [*c]Shader,
    pRootSignature: [*c]RootSignature,
    pWorkgraphName: [*c]const u8,
};

pub const PipelineDesc = extern struct {
    __union_field1: __Union0,
    pCache: [*c]PipelineCache,
    pPipelineExtensions: ?*anyopaque,
    pName: [*c]const u8,
    mType: PipelineType,
    mExtensionCount: u32,

    pub const __Union0 = extern union {
        mComputeDesc: ComputePipelineDesc,
        mGraphicsDesc: GraphicsPipelineDesc,
        mWorkgraphDesc: WorkgraphPipelineDesc,
        mMeshDesc: MeshPipelineDesc,
    };
};

pub const Pipeline = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        __union_field1: __Union0,
        pRootSignature: [*c]const RootSignature,
        mType: PipelineType,
        mPrimitiveTopology: D3D_PRIMITIVE_TOPOLOGY,

        pub const __Union0 = extern union {
            pPipelineState: *ID3D12PipelineState,
            __struct_field1: __Struct1,

            pub const __Struct1 = extern struct {
                pStateObject: *ID3D12StateObject,
                pWorkgraphName: *WCHAR,
            };
        };
    };
};

pub const PipelineCacheFlags = extern struct {
    bits: c_int = 0,

    pub const PIPELINE_CACHE_FLAG_NONE: PipelineCacheFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const PIPELINE_CACHE_FLAG_EXTERNALLY_SYNCHRONIZED: PipelineCacheFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(PipelineCacheFlags);
};

pub const PipelineCacheDesc = extern struct {
    /// Initial pipeline cache data (can be NULL which means empty pipeline cache)
    pData: ?*anyopaque,
    /// Initial pipeline cache size
    mSize: usize,
    mFlags: PipelineCacheFlags,
};

pub const PipelineCache = extern struct {
    mDx: __Struct0,

    pub const __Struct0 = extern struct {
        pLibrary: *ID3D12PipelineLibrary,
        pData: ?*anyopaque,
    };
};

pub const WorkgraphDesc = extern struct {
    pPipeline: [*c]Pipeline,
};

pub const Workgraph = extern struct {
    pBackingBuffer: [*c]Buffer,
    pPipeline: [*c]Pipeline,
    mId: D3D12_PROGRAM_IDENTIFIER,
};

pub const DispatchGraphInputType = extern struct {
    bits: c_int = 0,

    pub const DISPATCH_GRAPH_INPUT_CPU: DispatchGraphInputType = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const DISPATCH_GRAPH_INPUT_GPU: DispatchGraphInputType = .{ .bits = DispatchGraphInputType.DISPATCH_GRAPH_INPUT_CPU.bits + 1 };
    pub const DISPATCH_GRAPH_INPUT_COUNT: DispatchGraphInputType = .{ .bits = DispatchGraphInputType.DISPATCH_GRAPH_INPUT_CPU.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(DispatchGraphInputType);
};

pub const DispatchGraphDesc = extern struct {
    pWorkgraph: [*c]Workgraph,
    __union_field1: __Union0,
    mInputType: DispatchGraphInputType,
    mInitialize: bool,

    pub const __Union0 = extern union {
        __struct_field1: __Struct0,
        __struct_field3: __Struct2,

        pub const __Struct0 = extern struct {
            pInput: ?*anyopaque,
            mInputStride: u32,
        };

        pub const __Struct2 = extern struct {
            pInputBuffer: [*c]Buffer,
            mInputBufferOffset: u32,
        };
    };
};

pub const SwapChainCreationFlags = extern struct {
    bits: c_int = 0,

    pub const SWAP_CHAIN_CREATION_FLAG_NONE: SwapChainCreationFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const SWAP_CHAIN_CREATION_FLAG_ENABLE_FOVEATED_RENDERING_VR: SwapChainCreationFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(SwapChainCreationFlags);
};

pub const SwapChainDesc = extern struct {
    /// Window handle
    mWindowHandle: WindowHandle,
    /// Queues which should be allowed to present
    ppPresentQueues: [*c][*c]Queue,
    /// Number of present queues
    mPresentQueueCount: u32,
    /// Number of backbuffers in this swapchain
    mImageCount: u32,
    /// Width of the swapchain
    mWidth: u32,
    /// Height of the swapchain
    mHeight: u32,
    /// Color format of the swapchain
    mColorFormat: TinyImageFormat,
    /// Clear value
    mColorClearValue: ClearValue,
    /// Swapchain creation flags
    mFlags: SwapChainCreationFlags,
    /// Set whether swap chain will be presented using vsync
    mEnableVsync: bool,
    /// We can toggle to using FLIP model if app desires.
    mUseFlipSwapEffect: bool,
    /// Optional colorspace for HDR
    mColorSpace: ColorSpace,
};

pub const SwapChain = extern struct {
    /// Render targets created from the swapchain back buffers
    ppRenderTargets: [*c][*c]RenderTarget,
    mDx: __Struct0,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mImageCount: u8, // 8 bits
        mEnableVsync: u1, // 9 bits
        mColorSpace: u4, // 13 bits
        mFormat: u8, // 21 bits
        /// Padding added by c2z
        _dummy_padding: u11,
    },

    pub const __Struct0 = extern struct {
        /// Use IDXGISwapChain3 for now since IDXGISwapChain4
        /// isn't supported by older devices.
        pSwapChain: *IDXGISwapChain3,
        bitfield_1: packed struct(u32) {
            // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

            /// Sync interval to specify how interval for vsync
            mSyncInterval: u3, // 3 bits
            mFlags: u10, // 13 bits
            /// Padding added by c2z
            _dummy_padding: u19,
        },
    };
};

pub const ShaderTarget = extern struct {
    bits: c_int = 0,

    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_5_1: ShaderTarget = .{ .bits = 0 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_0: ShaderTarget = .{ .bits = 1 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_1: ShaderTarget = .{ .bits = 2 };
    /// 5.1 is supported on all DX12 hardware
    pub const SHADER_TARGET_6_2: ShaderTarget = .{ .bits = 3 };
    /// required for Raytracing
    pub const SHADER_TARGET_6_3: ShaderTarget = .{ .bits = 4 };
    /// required for VRS
    pub const SHADER_TARGET_6_4: ShaderTarget = .{ .bits = 5 };
    pub const SHADER_TARGET_6_5: ShaderTarget = .{ .bits = 6 };
    ///required for Dynamic Resources
    pub const SHADER_TARGET_6_6: ShaderTarget = .{ .bits = 7 };
    pub const SHADER_TARGET_6_7: ShaderTarget = .{ .bits = 8 };
    ///required for SV_StartVertexLocation and SV_StartInstanceLocation
    pub const SHADER_TARGET_6_8: ShaderTarget = .{ .bits = 9 };

    // pub usingnamespace cpp.FlagsMixin(ShaderTarget);
};

pub const GpuMode = extern struct {
    bits: c_int = 0,

    pub const GPU_MODE_SINGLE: GpuMode = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const GPU_MODE_LINKED: GpuMode = .{ .bits = GpuMode.GPU_MODE_SINGLE.bits + 1 };
    pub const GPU_MODE_UNLINKED: GpuMode = .{ .bits = GpuMode.GPU_MODE_SINGLE.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(GpuMode);
};

pub const RendererDesc = extern struct {
    mDx: __Struct0,
    mShaderTarget: ShaderTarget,
    mGpuMode: GpuMode,
    /// Apps may want to query additional state for their applications. That information is transferred through here.
    pExtendedSettings: *ExtendedSettings,
    /// Required when creating unlinked multiple renderers. Optional otherwise, can be used for explicit GPU selection.
    pContext: [*c]RendererContext,
    mGpuIndex: u32,
    /// This results in new validation not possible during API calls on the CPU, by creating patched shaders that have validation added
    /// directly to the shader. However, it can slow things down a lot, especially for applications with numerous PSOs. Time to see the
    /// first render frame may take several minutes
    mEnableGpuBasedValidation: bool,
    /// to align on PC on 40 bytes
    mPaddingA: bool,
    mPaddingB: bool,
    mPaddingC: bool,

    pub const __Struct0 = extern struct {
        mFeatureLevel: D3D_FEATURE_LEVEL,
    };
};

pub const GPUVendorPreset = extern struct {
    mVendorId: u32,
    mModelId: u32,
    /// Optional as not all gpu's have that. Default is : 0x00
    mRevisionId: u32,
    mPresetLevel: GPUPresetLevel,
    mVendorName: [256]u8,
    /// If GPU Name is missing then value will be empty string
    mGpuName: [256]u8,
    mGpuDriverVersion: [256]u8,
    mGpuDriverDate: [256]u8,
    mRTCoresCount: u32,
};

/// if you made change to this structure, please update GraphicsConfig.cpp FORMAT_CAPABILITY_COUNT
pub const FormatCapability = extern struct {
    bits: c_int = 0,

    pub const FORMAT_CAP_NONE: FormatCapability = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const FORMAT_CAP_LINEAR_FILTER: FormatCapability = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const FORMAT_CAP_READ: FormatCapability = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const FORMAT_CAP_WRITE: FormatCapability = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const FORMAT_CAP_READ_WRITE: FormatCapability = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const FORMAT_CAP_RENDER_TARGET: FormatCapability = .{ .bits = @as(c_uint, @intCast(16)) };

    // pub usingnamespace cpp.FlagsMixin(FormatCapability);
};

/// if you made change to this structure, please update GraphicsConfig.cpp FORMAT_CAPABILITY_COUNT
pub const WaveOpsSupportFlags = extern struct {
    bits: c_int = 0,

    pub const WAVE_OPS_SUPPORT_FLAG_NONE: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(0)) };
    pub const WAVE_OPS_SUPPORT_FLAG_BASIC_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const WAVE_OPS_SUPPORT_FLAG_VOTE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    pub const WAVE_OPS_SUPPORT_FLAG_ARITHMETIC_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(4)) };
    pub const WAVE_OPS_SUPPORT_FLAG_BALLOT_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(8)) };
    pub const WAVE_OPS_SUPPORT_FLAG_SHUFFLE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(16)) };
    pub const WAVE_OPS_SUPPORT_FLAG_SHUFFLE_RELATIVE_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(32)) };
    pub const WAVE_OPS_SUPPORT_FLAG_CLUSTERED_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const WAVE_OPS_SUPPORT_FLAG_QUAD_BIT: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(128)) };
    pub const WAVE_OPS_SUPPORT_FLAG_PARTITIONED_BIT_NV: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const WAVE_OPS_SUPPORT_FLAG_ALL: WaveOpsSupportFlags = .{ .bits = @as(c_uint, @intCast(2147483647)) };

    // pub usingnamespace cpp.FlagsMixin(WaveOpsSupportFlags);
};

pub const GpuDesc = extern struct {
    mDx: __Struct0,
    mFormatCaps: [239]FormatCapability,
    ///**********************************************************************************
    ///
    /// GPU Properties
    ///**********************************************************************************
    ///
    /// update availableGpuProperties, setDefaultGPUProperties in GraphicsConfig.cpp
    /// if you made changes to this list
    mVRAM: u64,
    mUniformBufferAlignment: u32,
    mUploadBufferAlignment: u32,
    mUploadBufferTextureAlignment: u32,
    mUploadBufferTextureRowAlignment: u32,
    mMaxVertexInputBindings: u32,
    mMaxRootSignatureDWORDS: u32,
    mWaveLaneCount: u32,
    mWaveOpsSupportFlags: WaveOpsSupportFlags,
    mGpuVendorPreset: GPUVendorPreset,
    mWaveOpsSupportedStageFlags: ShaderStage,
    mMaxTotalComputeThreads: u32,
    mMaxComputeThreads: [3]u32,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mMultiDrawIndirect: u1, // 1 bits
        mMultiDrawIndirectCount: u1, // 2 bits
        mRootConstant: u1, // 3 bits
        mIndirectRootConstant: u1, // 4 bits
        mBuiltinDrawID: u1, // 5 bits
        mIndirectCommandBuffer: u1, // 6 bits
        mROVsSupported: u1, // 7 bits
        mTessellationSupported: u1, // 8 bits
        mGeometryShaderSupported: u1, // 9 bits
        mGpuMarkers: u1, // 10 bits
        mHDRSupported: u1, // 11 bits
        mTimestampQueries: u1, // 12 bits
        mOcclusionQueries: u1, // 13 bits
        mPipelineStatsQueries: u1, // 14 bits
        mAllowBufferTextureInSameHeap: u1, // 15 bits
        mRaytracingSupported: u1, // 16 bits
        mUnifiedMemorySupported: u1, // 17 bits
        mRayPipelineSupported: u1, // 18 bits
        mRayQuerySupported: u1, // 19 bits
        mWorkgraphSupported: u1, // 20 bits
        mSoftwareVRSSupported: u1, // 21 bits
        mPrimitiveIdSupported: u1, // 22 bits
        mPrimitiveIdPsSupported: u1, // 23 bits
        m64BitAtomicsSupported: u1, // 24 bits
        mMeshletSupported: u1, // 25 bits
        /// Padding added by c2z
        _dummy_padding: u7,
    },

    mFeatureLevel: D3D_FEATURE_LEVEL,
    bitfield_2: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSuppressInvalidSubresourceStateAfterExit: u1, // 1 bits
        /// Padding added by c2z
        _dummy_padding: u31,
    },

    mMaxBoundTextures: u32,
    bitfield_3: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mSamplerAnisotropySupported: u1, // 1 bits
        mGraphicsQueueSupported: u1, // 2 bits
        /// Padding added by c2z
        _dummy_padding: u30,
    },

    mAmdAsicFamily: u32,
    mFrameBufferSamplesCount: u32,

    pub const __Struct0 = extern struct {
        pGpu: *IDXGIAdapter4,
    };
};

pub const Renderer = extern struct {
    mDx: __Struct0,
    pNullDescriptors: *NullDescriptors,
    pContext: [*c]RendererContext,
    pGpu: [*c]const GpuDesc,
    pName: [*c]const u8,
    mRendererApi: RendererApi,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mLinkedNodeCount: u4, // 4 bits
        mUnlinkedRendererIndex: u4, // 8 bits
        mGpuMode: u3, // 11 bits
        mShaderTarget: u4, // 15 bits
        mOwnsContext: u1, // 16 bits
        /// Padding added by c2z
        _dummy_padding: u16,
    },

    pub const __Struct0 = extern struct {
        /// API specific descriptor heap and memory allocator
        pCPUDescriptorHeaps: [*c]*DescriptorHeap,
        pCbvSrvUavHeaps: [*c]*DescriptorHeap,
        pSamplerHeaps: [*c]*DescriptorHeap,
        pResourceAllocator: *D3D12MAAllocator,
        pDevice: *ID3D12Device,
        pDebugValidation: *ID3D12InfoQueue1,
        mCallbackCookie: DWORD,
        mUseDebugCallback: bool,
        mSuppressMismatchingCommandListDuringPresent: bool,
    };

    // opaques

    const NullDescriptors = anyopaque;
};

pub const RendererContextDesc = extern struct {
    mDx: __Struct0,
    mEnableGpuBasedValidation: bool,

    pub const __Struct0 = extern struct {
        mFeatureLevel: D3D_FEATURE_LEVEL,
    };
};

pub const RendererContext = extern struct {
    mDx: __Struct0,
    mGpus: [4]GpuDesc,
    mGpuCount: u32,

    pub const __Struct0 = extern struct {
        pDXGIFactory: *IDXGIFactory6,
        pDebug: *ID3D12Debug,
    };
};

pub const DescriptorSetDesc = extern struct {
    pRootSignature: [*c]RootSignature,
    mUpdateFrequency: DescriptorUpdateFrequency,
    mMaxSets: u32,
    mNodeIndex: u32,
};

pub const QueueSubmitDesc = extern struct {
    ppCmds: [*c][*c]Cmd,
    pSignalFence: [*c]Fence,
    ppWaitSemaphores: [*c][*c]Semaphore,
    ppSignalSemaphores: [*c][*c]Semaphore,
    mCmdCount: u32,
    mWaitSemaphoreCount: u32,
    mSignalSemaphoreCount: u32,
    mSubmitDone: bool,
};

pub const QueuePresentDesc = extern struct {
    pSwapChain: [*c]SwapChain,
    ppWaitSemaphores: [*c][*c]Semaphore,
    mWaitSemaphoreCount: u32,
    mIndex: u8,
    mSubmitDone: bool,
};

pub const BindRenderTargetDesc = extern struct {
    pRenderTarget: [*c]RenderTarget,
    mLoadAction: LoadActionType,
    mStoreAction: StoreActionType,
    mClearValue: ClearValue,
    mLoadActionStencil: LoadActionType,
    mStoreActionStencil: StoreActionType,
    mArraySlice: u32,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mMipSlice: u10, // 10 bits
        mOverrideClearValue: u1, // 11 bits
        mUseArraySlice: u1, // 12 bits
        mUseMipSlice: u1, // 13 bits
        /// Padding added by c2z
        _dummy_padding: u19,
    },
};

pub const BindDepthTargetDesc = extern struct {
    pDepthStencil: [*c]RenderTarget,
    mLoadAction: LoadActionType,
    mLoadActionStencil: LoadActionType,
    mStoreAction: StoreActionType,
    mStoreActionStencil: StoreActionType,
    mClearValue: ClearValue,
    mArraySlice: u32,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        mMipSlice: u10, // 10 bits
        mOverrideClearValue: u1, // 11 bits
        mUseArraySlice: u1, // 12 bits
        mUseMipSlice: u1, // 13 bits
        /// Padding added by c2z
        _dummy_padding: u19,
    },
};

/// Uses render targets' sample count in bindRenderTargetsDesc
pub const SampleLocationDesc = extern struct {
    pLocations: [*c]SampleLocations,
    mGridSizeX: u32,
    mGridSizeY: u32,
};

/// Uses render targets' sample count in bindRenderTargetsDesc
pub const BindRenderTargetsDesc = extern struct {
    mRenderTargetCount: u32,
    mRenderTargets: [8]BindRenderTargetDesc,
    mDepthStencil: BindDepthTargetDesc,
    mSampleLocation: SampleLocationDesc,
    /// Explicit viewport for empty render pass
    mExtent: [2]u32,
};

// TIDES: BEGIN MANUAL CHANGES
pub const ViewportDesc = extern struct {
    mX: f32,
    mY: f32,
    mWidth: f32,
    mHeight: f32,
    mMinDepth: f32,
    mMaxDepth: f32,
};

pub const ScissorDesc = extern struct {
    mLeft: u32,
    mTop: u32,
    mRight: u32,
    mBottom: u32,
};
// TIDES: END MANUAL CHANGES

// TIDES: BEGIN MANUAL CHANGES
extern fn _1_initGPUConfiguration_(pExtendedSettings: [*c]ExtendedSettings) void;
pub const initGPUConfiguration = _1_initGPUConfiguration_;
// TIDES: END MANUAL CHANGES

extern fn _1_initRendererContext_(appName: [*c]const u8, pSettings: [*c]const RendererContextDesc, ppContext: [*c][*c]RendererContext) void;
/// Multiple renderer API (optional)
pub const initRendererContext = _1_initRendererContext_;

extern fn _1_exitRendererContext_(pContext: [*c]RendererContext) void;
pub const exitRendererContext = _1_exitRendererContext_;

extern fn _1_initRenderer_(appName: [*c]const u8, pSettings: [*c]const RendererDesc, ppRenderer: [*c][*c]Renderer) void;
/// allocates memory and initializes the renderer -> returns pRenderer
pub const initRenderer = _1_initRenderer_;

extern fn _1_exitRenderer_(pRenderer: [*c]Renderer) void;
pub const exitRenderer = _1_exitRenderer_;

extern fn _1_initFence_(pRenderer: [*c]Renderer, ppFence: [*c][*c]Fence) void;
pub const initFence = _1_initFence_;

extern fn _1_exitFence_(pRenderer: [*c]Renderer, pFence: [*c]Fence) void;
pub const exitFence = _1_exitFence_;

extern fn _1_initSemaphore_(pRenderer: [*c]Renderer, ppSemaphore: [*c][*c]Semaphore) void;
pub const initSemaphore = _1_initSemaphore_;

extern fn _1_exitSemaphore_(pRenderer: [*c]Renderer, pSemaphore: [*c]Semaphore) void;
pub const exitSemaphore = _1_exitSemaphore_;

extern fn _1_initQueue_(pRenderer: [*c]Renderer, pQDesc: [*c]QueueDesc, ppQueue: [*c][*c]Queue) void;
pub const initQueue = _1_initQueue_;

extern fn _1_exitQueue_(pRenderer: [*c]Renderer, pQueue: [*c]Queue) void;
pub const exitQueue = _1_exitQueue_;

extern fn _1_addSwapChain_(pRenderer: [*c]Renderer, pDesc: [*c]const SwapChainDesc, ppSwapChain: [*c][*c]SwapChain) void;
pub const addSwapChain = _1_addSwapChain_;

extern fn _1_removeSwapChain_(pRenderer: [*c]Renderer, pSwapChain: [*c]SwapChain) void;
pub const removeSwapChain = _1_removeSwapChain_;

extern fn _1_addResourceHeap_(pRenderer: [*c]Renderer, pDesc: [*c]const ResourceHeapDesc, ppHeap: [*c][*c]ResourceHeap) void;
/// memory functions
pub const addResourceHeap = _1_addResourceHeap_;

extern fn _1_removeResourceHeap_(pRenderer: [*c]Renderer, pHeap: [*c]ResourceHeap) void;
pub const removeResourceHeap = _1_removeResourceHeap_;

extern fn _1_initCmdPool_(pRenderer: [*c]Renderer, pDesc: [*c]const CmdPoolDesc, ppCmdPool: [*c][*c]CmdPool) void;
/// command pool functions
pub const initCmdPool = _1_initCmdPool_;

extern fn _1_exitCmdPool_(pRenderer: [*c]Renderer, pCmdPool: [*c]CmdPool) void;
pub const exitCmdPool = _1_exitCmdPool_;

extern fn _1_initCmd_(pRenderer: [*c]Renderer, pDesc: [*c]const CmdDesc, ppCmd: [*c][*c]Cmd) void;
pub const initCmd = _1_initCmd_;

extern fn _1_exitCmd_(pRenderer: [*c]Renderer, pCmd: [*c]Cmd) void;
pub const exitCmd = _1_exitCmd_;

extern fn _1_initCmd_n_(pRenderer: [*c]Renderer, pDesc: [*c]const CmdDesc, cmdCount: u32, pppCmds: [*c][*c][*c]Cmd) void;
pub const initCmd_n = _1_initCmd_n_;

extern fn _1_exitCmd_n_(pRenderer: [*c]Renderer, cmdCount: u32, ppCmds: [*c][*c]Cmd) void;
pub const exitCmd_n = _1_exitCmd_n_;

extern fn _1_addRenderTarget_(pRenderer: [*c]Renderer, pDesc: [*c]const RenderTargetDesc, ppRenderTarget: [*c][*c]RenderTarget) void;
/// All buffer, texture loading handled by resource system -> IResourceLoader.*
pub const addRenderTarget = _1_addRenderTarget_;

extern fn _1_removeRenderTarget_(pRenderer: [*c]Renderer, pRenderTarget: [*c]RenderTarget) void;
pub const removeRenderTarget = _1_removeRenderTarget_;

extern fn _1_addSampler_(pRenderer: [*c]Renderer, pDesc: [*c]const SamplerDesc, bindless: bool, ppSampler: [*c][*c]Sampler) void;
pub const addSampler = _1_addSampler_;

extern fn _1_removeSampler_(pRenderer: [*c]Renderer, pSampler: [*c]Sampler) void;
pub const removeSampler = _1_removeSampler_;

extern fn _1_addShaderBinary_(pRenderer: [*c]Renderer, pDesc: [*c]const BinaryShaderDesc, ppShaderProgram: [*c][*c]Shader) void;
/// shader functions
pub const addShaderBinary = _1_addShaderBinary_;

extern fn _1_removeShader_(pRenderer: [*c]Renderer, pShaderProgram: [*c]Shader) void;
pub const removeShader = _1_removeShader_;

extern fn _1_addRootSignature_(pRenderer: [*c]Renderer, pDesc: [*c]const RootSignatureDesc, ppRootSignature: [*c][*c]RootSignature) void;
pub const addRootSignature = _1_addRootSignature_;

extern fn _1_removeRootSignature_(pRenderer: [*c]Renderer, pRootSignature: [*c]RootSignature) void;
pub const removeRootSignature = _1_removeRootSignature_;

extern fn _1_getDescriptorIndexFromName_(pRootSignature: [*c]const RootSignature, pName: [*c]const u8) u32;
pub const getDescriptorIndexFromName = _1_getDescriptorIndexFromName_;

extern fn _1_addPipeline_(pRenderer: [*c]Renderer, pPipelineSettings: [*c]const PipelineDesc, ppPipeline: [*c][*c]Pipeline) void;
/// pipeline functions
pub const addPipeline = _1_addPipeline_;

extern fn _1_removePipeline_(pRenderer: [*c]Renderer, pPipeline: [*c]Pipeline) void;
pub const removePipeline = _1_removePipeline_;

extern fn _1_addPipelineCache_(pRenderer: [*c]Renderer, pDesc: [*c]const PipelineCacheDesc, ppPipelineCache: [*c][*c]PipelineCache) void;
pub const addPipelineCache = _1_addPipelineCache_;

extern fn _1_getPipelineCacheData_(pRenderer: [*c]Renderer, pPipelineCache: [*c]PipelineCache, pSize: [*c]usize, pData: ?*anyopaque) void;
pub const getPipelineCacheData = _1_getPipelineCacheData_;

extern fn _1_removePipelineCache_(pRenderer: [*c]Renderer, pPipelineCache: [*c]PipelineCache) void;
pub const removePipelineCache = _1_removePipelineCache_;

extern fn _1_addDescriptorSet_(pRenderer: [*c]Renderer, pDesc: [*c]const DescriptorSetDesc, ppDescriptorSet: [*c][*c]DescriptorSet) void;
/// Descriptor Set functions
pub const addDescriptorSet = _1_addDescriptorSet_;

extern fn _1_removeDescriptorSet_(pRenderer: [*c]Renderer, pDescriptorSet: [*c]DescriptorSet) void;
pub const removeDescriptorSet = _1_removeDescriptorSet_;

extern fn _1_updateDescriptorSet_(pRenderer: [*c]Renderer, index: u32, pDescriptorSet: [*c]DescriptorSet, count: u32, pParams: [*c]const DescriptorData) void;
pub const updateDescriptorSet = _1_updateDescriptorSet_;

extern fn _1_resetCmdPool_(pRenderer: [*c]Renderer, pCmdPool: [*c]CmdPool) void;
/// command buffer functions
pub const resetCmdPool = _1_resetCmdPool_;

extern fn _1_beginCmd_(pCmd: [*c]Cmd) void;
pub const beginCmd = _1_beginCmd_;

extern fn _1_endCmd_(pCmd: [*c]Cmd) void;
pub const endCmd = _1_endCmd_;

extern fn _1_cmdBindRenderTargets_(pCmd: [*c]Cmd, pDesc: [*c]const BindRenderTargetsDesc) void;
pub const cmdBindRenderTargets = _1_cmdBindRenderTargets_;

extern fn _1_cmdSetViewport_(pCmd: [*c]Cmd, x: f32, y: f32, width: f32, height: f32, minDepth: f32, maxDepth: f32) void;
pub const cmdSetViewport = _1_cmdSetViewport_;

extern fn _1_cmdSetScissor_(pCmd: [*c]Cmd, x: u32, y: u32, width: u32, height: u32) void;
pub const cmdSetScissor = _1_cmdSetScissor_;

// TIDES: BEGIN MANUAL CHANGES
extern fn _1_cmdSetViewports_(pCmd: [*c]Cmd, pViewportDescs: [*c]const ViewportDesc, viewportCount: u32) void;
pub const cmdSetViewports = _1_cmdSetViewports_;

extern fn _1_cmdSetScissors_(pCmd: [*c]Cmd, pScissorDescs: [*c]const ScissorDesc, scissorCount: u32) void;
pub const cmdSetScissors = _1_cmdSetScissors_;
// TIDES: END MANUAL CHANGES

extern fn _1_cmdSetStencilReferenceValue_(pCmd: [*c]Cmd, val: u32) void;
pub const cmdSetStencilReferenceValue = _1_cmdSetStencilReferenceValue_;

extern fn _1_cmdBindPipeline_(pCmd: [*c]Cmd, pPipeline: [*c]Pipeline) void;
pub const cmdBindPipeline = _1_cmdBindPipeline_;

extern fn _1_cmdBindDescriptorSet_(pCmd: [*c]Cmd, index: u32, pDescriptorSet: [*c]DescriptorSet) void;
pub const cmdBindDescriptorSet = _1_cmdBindDescriptorSet_;

extern fn _1_cmdBindPushConstants_(pCmd: [*c]Cmd, pRootSignature: [*c]RootSignature, paramIndex: u32, pConstants: ?*const anyopaque) void;
pub const cmdBindPushConstants = _1_cmdBindPushConstants_;

extern fn _1_cmdBindDescriptorSetWithRootCbvs_(pCmd: [*c]Cmd, index: u32, pDescriptorSet: [*c]DescriptorSet, count: u32, pParams: [*c]const DescriptorData) void;
pub const cmdBindDescriptorSetWithRootCbvs = _1_cmdBindDescriptorSetWithRootCbvs_;

extern fn _1_cmdBindIndexBuffer_(pCmd: [*c]Cmd, pBuffer: [*c]Buffer, indexType: u32, offset: u64) void;
pub const cmdBindIndexBuffer = _1_cmdBindIndexBuffer_;

extern fn _1_cmdBindVertexBuffer_(pCmd: [*c]Cmd, bufferCount: u32, ppBuffers: [*c][*c]Buffer, pStrides: [*c]const u32, pOffsets: [*c]const u64) void;
pub const cmdBindVertexBuffer = _1_cmdBindVertexBuffer_;

extern fn _1_cmdDraw_(pCmd: [*c]Cmd, vertexCount: u32, firstVertex: u32) void;
pub const cmdDraw = _1_cmdDraw_;

extern fn _1_cmdDrawInstanced_(pCmd: [*c]Cmd, vertexCount: u32, firstVertex: u32, instanceCount: u32, firstInstance: u32) void;
pub const cmdDrawInstanced = _1_cmdDrawInstanced_;

extern fn _1_cmdDrawIndexed_(pCmd: [*c]Cmd, indexCount: u32, firstIndex: u32, firstVertex: u32) void;
pub const cmdDrawIndexed = _1_cmdDrawIndexed_;

extern fn _1_cmdDrawIndexedInstanced_(pCmd: [*c]Cmd, indexCount: u32, firstIndex: u32, instanceCount: u32, firstVertex: u32, firstInstance: u32) void;
pub const cmdDrawIndexedInstanced = _1_cmdDrawIndexedInstanced_;

extern fn _1_cmdDispatch_(pCmd: [*c]Cmd, groupCountX: u32, groupCountY: u32, groupCountZ: u32) void;
pub const cmdDispatch = _1_cmdDispatch_;

extern fn _1_cmdResourceBarrier_(pCmd: [*c]Cmd, bufferBarrierCount: u32, pBufferBarriers: [*c]BufferBarrier, textureBarrierCount: u32, pTextureBarriers: [*c]TextureBarrier, rtBarrierCount: u32, pRtBarriers: [*c]RenderTargetBarrier) void;
/// Transition Commands
pub const cmdResourceBarrier = _1_cmdResourceBarrier_;

extern fn _1_acquireNextImage_(pRenderer: [*c]Renderer, pSwapChain: [*c]SwapChain, pSignalSemaphore: [*c]Semaphore, pFence: [*c]Fence, pImageIndex: [*c]u32) void;
/// queue/fence/swapchain functions
pub const acquireNextImage = _1_acquireNextImage_;

extern fn _1_queueSubmit_(pQueue: [*c]Queue, pDesc: [*c]const QueueSubmitDesc) void;
pub const queueSubmit = _1_queueSubmit_;

extern fn _1_queuePresent_(pQueue: [*c]Queue, pDesc: [*c]const QueuePresentDesc) void;
pub const queuePresent = _1_queuePresent_;

extern fn _1_waitQueueIdle_(pQueue: [*c]Queue) void;
pub const waitQueueIdle = _1_waitQueueIdle_;

extern fn _1_getFenceStatus_(pRenderer: [*c]Renderer, pFence: [*c]Fence, pFenceStatus: [*c]FenceStatus) void;
pub const getFenceStatus = _1_getFenceStatus_;

extern fn _1_waitForFences_(pRenderer: [*c]Renderer, fenceCount: u32, ppFences: [*c][*c]Fence) void;
pub const waitForFences = _1_waitForFences_;

extern fn _1_toggleVSync_(pRenderer: [*c]Renderer, ppSwapchain: [*c][*c]SwapChain) void;
pub const toggleVSync = _1_toggleVSync_;

extern fn _1_getSupportedSwapchainFormat_(pRenderer: [*c]Renderer, pDesc: [*c]const SwapChainDesc, colorSpace: ColorSpace) TinyImageFormat;
///Returns the recommended format for the swapchain.
///If true is passed for the hintHDR parameter, it will return an HDR format IF the platform supports it
///If false is passed or the platform does not support HDR a non HDR format is returned.
///If true is passed for the hintSrgb parameter, it will return format that is will do gamma correction automatically
///If false is passed for the hintSrgb parameter the gamma correction should be done as a postprocess step before submitting image to swapchain
pub const getSupportedSwapchainFormat = _1_getSupportedSwapchainFormat_;

extern fn _1_getRecommendedSwapchainImageCount_(pRenderer: [*c]Renderer, hwnd: [*c]const WindowHandle) u32;
pub const getRecommendedSwapchainImageCount = _1_getRecommendedSwapchainImageCount_;

extern fn _1_cmdExecuteIndirect_(pCmd: [*c]Cmd, type: IndirectArgumentType, maxCommandCount: c_uint, pIndirectBuffer: [*c]Buffer, bufferOffset: u64, pCounterBuffer: [*c]Buffer, counterBufferOffset: u64) void;
///indirect Draw functions
pub const cmdExecuteIndirect = _1_cmdExecuteIndirect_;

extern fn _1_addWorkgraph_(pRenderer: [*c]Renderer, pDesc: [*c]const WorkgraphDesc, ppWorkgraph: [*c][*c]Workgraph) void;
pub const addWorkgraph = _1_addWorkgraph_;

extern fn _1_removeWorkgraph_(pRenderer: [*c]Renderer, pWorkgraph: [*c]Workgraph) void;
pub const removeWorkgraph = _1_removeWorkgraph_;

extern fn _1_cmdDispatchWorkgraph_(pCmd: [*c]Cmd, pDesc: [*c]const DispatchGraphDesc) void;
pub const cmdDispatchWorkgraph = _1_cmdDispatchWorkgraph_;

extern fn _1_getTimestampFrequency_(pQueue: [*c]Queue, pFrequency: [*c]f64) void;
///*********************************************************************
///
/// GPU Query Interface
///*********************************************************************
pub const getTimestampFrequency = _1_getTimestampFrequency_;

extern fn _1_initQueryPool_(pRenderer: [*c]Renderer, pDesc: [*c]const QueryPoolDesc, ppQueryPool: [*c][*c]QueryPool) void;
pub const initQueryPool = _1_initQueryPool_;

extern fn _1_exitQueryPool_(pRenderer: [*c]Renderer, pQueryPool: [*c]QueryPool) void;
pub const exitQueryPool = _1_exitQueryPool_;

extern fn _1_cmdBeginQuery_(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, pQuery: [*c]QueryDesc) void;
pub const cmdBeginQuery = _1_cmdBeginQuery_;

extern fn _1_cmdEndQuery_(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, pQuery: [*c]QueryDesc) void;
pub const cmdEndQuery = _1_cmdEndQuery_;

extern fn _1_cmdResolveQuery_(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, startQuery: u32, queryCount: u32) void;
pub const cmdResolveQuery = _1_cmdResolveQuery_;

extern fn _1_cmdResetQuery_(pCmd: [*c]Cmd, pQueryPool: [*c]QueryPool, startQuery: u32, queryCount: u32) void;
pub const cmdResetQuery = _1_cmdResetQuery_;

extern fn _1_getQueryData_(pRenderer: [*c]Renderer, pQueryPool: [*c]QueryPool, queryIndex: u32, pOutData: [*c]QueryData) void;
pub const getQueryData = _1_getQueryData_;

extern fn _1_logMemoryStats_(pRenderer: [*c]Renderer) void;
///*********************************************************************
///
/// Stats Info Interface
///*********************************************************************
pub const logMemoryStats = _1_logMemoryStats_;

extern fn _1_calculateMemoryUse_(pRenderer: [*c]Renderer, usedBytes: [*c]u64, totalAllocatedBytes: [*c]u64) void;
pub const calculateMemoryUse = _1_calculateMemoryUse_;

extern fn _1_cmdBeginDebugMarker_(pCmd: [*c]Cmd, r: f32, g: f32, b: f32, pName: [*c]const u8) void;
///*********************************************************************
///
/// Debug Marker Interface
///*********************************************************************
pub const cmdBeginDebugMarker = _1_cmdBeginDebugMarker_;

extern fn _1_cmdEndDebugMarker_(pCmd: [*c]Cmd) void;
pub const cmdEndDebugMarker = _1_cmdEndDebugMarker_;

extern fn _1_cmdAddDebugMarker_(pCmd: [*c]Cmd, r: f32, g: f32, b: f32, pName: [*c]const u8) void;
pub const cmdAddDebugMarker = _1_cmdAddDebugMarker_;

extern fn _1_cmdWriteMarker_(pCmd: [*c]Cmd, pDesc: [*c]const MarkerDesc) void;
pub const cmdWriteMarker = _1_cmdWriteMarker_;

extern fn _1_setBufferName_(pRenderer: [*c]Renderer, pBuffer: [*c]Buffer, pName: [*c]const u8) void;
///*********************************************************************
///
/// Resource Debug Naming Interface
///*********************************************************************
pub const setBufferName = _1_setBufferName_;

extern fn _1_setTextureName_(pRenderer: [*c]Renderer, pTexture: [*c]Texture, pName: [*c]const u8) void;
pub const setTextureName = _1_setTextureName_;

extern fn _1_setRenderTargetName_(pRenderer: [*c]Renderer, pRenderTarget: [*c]RenderTarget, pName: [*c]const u8) void;
pub const setRenderTargetName = _1_setRenderTargetName_;

extern fn _1_setPipelineName_(pRenderer: [*c]Renderer, pPipeline: [*c]Pipeline, pName: [*c]const u8) void;
pub const setPipelineName = _1_setPipelineName_;

// opaques

const D3D12MAAllocator = anyopaque;
const D3D12MAAllocation = anyopaque;
const RaytracingHitGroup = anyopaque;
const DescriptorIndexMap = anyopaque;
const Raytracing = anyopaque;
const EsramManager = anyopaque;
const AccelerationStructure = anyopaque;

// unnamed nodes

pub const UnnamedEnum0 = extern struct {
    bits: c_int = 0,

    pub const MAX_INSTANCE_EXTENSIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(64)) };
    pub const MAX_DEVICE_EXTENSIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(64)) };
    /// Max number of GPUs in SLI or Cross-Fire
    pub const MAX_LINKED_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPUs in unlinked mode
    pub const MAX_UNLINKED_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_MULTIPLE_GPUS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(4)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_RENDER_TARGET_ATTACHMENTS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(8)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_VERTEX_BINDINGS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(15)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_VERTEX_ATTRIBS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(15)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_RESOURCE_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(256)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_SEMANTIC_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_DEBUG_NAME_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(128)) };
    /// Max number of GPus for either linked or unlinked mode. must update WindowsBase::setupPlatformUI accordingly
    pub const MAX_MIP_LEVELS: UnnamedEnum0 = .{ .bits = 4294967295 };
    /// max size for GPUVendorPreset strings
    pub const MAX_GPU_VENDOR_STRING_LENGTH: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(256)) };
    pub const MAX_SAMPLE_LOCATIONS: UnnamedEnum0 = .{ .bits = @as(c_uint, @intCast(16)) };

    // pub usingnamespace cpp.FlagsMixin(UnnamedEnum0);
};
