// auto generated by c2z
#include <new>
#include "IResourceLoader.h"

extern "C" const void*              _1_gVertexBufferState_ = (void*)&::gVertexBufferState;
extern "C" const void*              _1_gIndexBufferState_ = (void*)&::gIndexBufferState;
extern "C" const void*              _1_GEOMETRY_FILE_MAGIC_STR_ = (void*)&::GEOMETRY_FILE_MAGIC_STR;
extern "C" TextureSubresourceUpdate _1_TextureUpdateDesc_getSubresourceUpdateDesc_(::TextureUpdateDesc* self, uint32_t mip, uint32_t layer)
{
    return self->getSubresourceUpdateDesc(mip, layer);
}
extern "C" const void* _1_gDefaultResourceLoaderDesc_ = (void*)&::gDefaultResourceLoaderDesc;
extern "C" void        _1_initResourceLoaderInterface_(Renderer* pRenderer, ResourceLoaderDesc* pDesc)
{
    ::initResourceLoaderInterface(pRenderer, pDesc);
}
extern "C" void _1_exitResourceLoaderInterface_(Renderer* pRenderer) { ::exitResourceLoaderInterface(pRenderer); }
extern "C" void _2_initResourceLoaderInterface_(Renderer** ppRenderers, uint32_t rendererCount, ResourceLoaderDesc* pDesc)
{
    ::initResourceLoaderInterface(ppRenderers, rendererCount, pDesc);
}
extern "C" void _2_exitResourceLoaderInterface_(Renderer** ppRenderers, uint32_t rendererCount)
{
    ::exitResourceLoaderInterface(ppRenderers, rendererCount);
}
extern "C" uint32_t _1_addMaterial_(const char* pMaterialFileName, Material** pMaterial, SyncToken* pSyncToken)
{
    return ::addMaterial(pMaterialFileName, pMaterial, pSyncToken);
}
extern "C" void     _1_removeMaterial_(Material* pMaterial) { ::removeMaterial(pMaterial); }
extern "C" uint32_t _1_getMaterialSetIndex_(Material* pMaterial, const char* name) { return ::getMaterialSetIndex(pMaterial, name); }
extern "C" void     _1_getMaterialShader_(Material* pMaterial, uint32_t materialSetIndex, Shader** ppOutShader)
{
    ::getMaterialShader(pMaterial, materialSetIndex, ppOutShader);
}
extern "C" void _1_getMaterialTextures_(Material* pMaterial, uint32_t materialSetIndex, const char** ppOutTextureBindingNames,
                                        Texture** ppOutTextures, uint32_t outTexturesSize)
{
    ::getMaterialTextures(pMaterial, materialSetIndex, ppOutTextureBindingNames, ppOutTextures, outTexturesSize);
}
extern "C" void _1_getResourceSizeAlign_(const BufferLoadDesc* pDesc, ResourceSizeAlign* pOut) { ::getResourceSizeAlign(pDesc, pOut); }
extern "C" void _2_getResourceSizeAlign_(const TextureLoadDesc* pDesc, ResourceSizeAlign* pOut) { ::getResourceSizeAlign(pDesc, pOut); }
extern "C" void _1_addResource_(BufferLoadDesc* pBufferDesc, SyncToken* token) { ::addResource(pBufferDesc, token); }
extern "C" void _2_addResource_(TextureLoadDesc* pTextureDesc, SyncToken* token) { ::addResource(pTextureDesc, token); }
extern "C" void _3_addResource_(GeometryLoadDesc* pGeomDesc, SyncToken* token) { ::addResource(pGeomDesc, token); }
extern "C" void _1_addGeometryBuffer_(GeometryBufferLoadDesc* pDesc) { ::addGeometryBuffer(pDesc); }
extern "C" void _1_beginUpdateResource_(BufferUpdateDesc* pBufferDesc) { ::beginUpdateResource(pBufferDesc); }
extern "C" void _2_beginUpdateResource_(TextureUpdateDesc* pTextureDesc) { ::beginUpdateResource(pTextureDesc); }
extern "C" void _1_endUpdateResource_(BufferUpdateDesc* pBuffer) { ::endUpdateResource(pBuffer); }
extern "C" void _2_endUpdateResource_(TextureUpdateDesc* pTexture) { ::endUpdateResource(pTexture); }
extern "C" void _1_addGeometryBufferPart_(BufferChunkAllocator* buffer, uint32_t size, uint32_t alignment, BufferChunk* pOut,
                                          BufferChunk* pPreferredChunk)
{
    ::addGeometryBufferPart(buffer, size, alignment, pOut, pPreferredChunk);
}
extern "C" void _1_removeGeometryBufferPart_(BufferChunkAllocator* buffer, BufferChunk* chunk)
{
    ::removeGeometryBufferPart(buffer, chunk);
}
extern "C" void       _1_flushResourceUpdates_(FlushResourceUpdateDesc* pDesc) { ::flushResourceUpdates(pDesc); }
extern "C" void       _1_copyResource_(TextureCopyDesc* pTextureDesc, SyncToken* token) { ::copyResource(pTextureDesc, token); }
extern "C" void       _1_removeResource_(Buffer* pBuffer) { ::removeResource(pBuffer); }
extern "C" void       _2_removeResource_(Texture* pTexture) { ::removeResource(pTexture); }
extern "C" void       _3_removeResource_(Geometry* pGeom) { ::removeResource(pGeom); }
extern "C" void       _4_removeResource_(GeometryData* pGeom) { ::removeResource(pGeom); }
extern "C" void       _1_removeGeometryBuffer_(GeometryBuffer* pGeomBuffer) { ::removeGeometryBuffer(pGeomBuffer); }
extern "C" void       _1_removeGeometryShadowData_(GeometryData* pGeom) { ::removeGeometryShadowData(pGeom); }
extern "C" bool       _1_allResourceLoadsCompleted_() { return ::allResourceLoadsCompleted(); }
extern "C" void       _1_waitForAllResourceLoads_() { ::waitForAllResourceLoads(); }
extern "C" void       _1_waitCopyQueueIdle_() { ::waitCopyQueueIdle(); }
extern "C" bool       _1_isResourceLoaderSingleThreaded_() { return ::isResourceLoaderSingleThreaded(); }
extern "C" SyncToken  _1_getLastTokenCompleted_() { return ::getLastTokenCompleted(); }
extern "C" bool       _1_isTokenCompleted_(const SyncToken* token) { return ::isTokenCompleted(token); }
extern "C" void       _1_waitForToken_(const SyncToken* token) { ::waitForToken(token); }
extern "C" SyncToken  _1_getLastTokenSubmitted_() { return ::getLastTokenSubmitted(); }
extern "C" bool       _1_isTokenSubmitted_(const SyncToken* token) { return ::isTokenSubmitted(token); }
extern "C" void       _1_waitForTokenSubmitted_(const SyncToken* token) { ::waitForTokenSubmitted(token); }
extern "C" Semaphore* _1_getLastSemaphoreSubmitted_(uint32_t nodeIndex) { return ::getLastSemaphoreSubmitted(nodeIndex); }
extern "C" void       _1_addShader_(Renderer* pRenderer, const ShaderLoadDesc* pDesc, Shader** pShader)
{
    ::addShader(pRenderer, pDesc, pShader);
}
extern "C" void _1_loadPipelineCache_(Renderer* pRenderer, const PipelineCacheLoadDesc* pDesc, PipelineCache** ppPipelineCache)
{
    ::loadPipelineCache(pRenderer, pDesc, ppPipelineCache);
}
extern "C" void _1_savePipelineCache_(Renderer* pRenderer, PipelineCache* pPipelineCache, PipelineCacheSaveDesc* pDesc)
{
    ::savePipelineCache(pRenderer, pPipelineCache, pDesc);
}
extern "C" bool _1_isUma_() { return ::isUma(); }
